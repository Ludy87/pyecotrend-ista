{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyEcoTrend-ista","text":"<p>\u2728 Wishlist from Amazon \u2728</p> <p>Unofficial python library for the pyecotrend-ista API</p> <p></p>"},{"location":"#pyecotrend_ista","title":"pyecotrend_ista","text":"<p>pyecotrend ista.</p>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError","title":"KeycloakAuthenticationError","text":"<pre><code>KeycloakAuthenticationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak authentication error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakError","title":"KeycloakError","text":"<pre><code>KeycloakError(error_message='', response_code=None, response_body=None)</code></pre> <p>Base class for custom Keycloak errors.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The response status code :type response_code: int</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>:returns: String representation of the object :rtype: str</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    :returns: String representation of the object\n    :rtype: str\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    else:\n        return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakGetError","title":"KeycloakGetError","text":"<pre><code>KeycloakGetError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request get error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError","title":"KeycloakInvalidTokenError","text":"<pre><code>KeycloakInvalidTokenError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak invalid token exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakOperationError","title":"KeycloakOperationError","text":"<pre><code>KeycloakOperationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak operation error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakPostError","title":"KeycloakPostError","text":"<pre><code>KeycloakPostError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request post error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.LoginError","title":"LoginError","text":"<p>Exception raised for login- and authentication related errors.</p> <p>This exception is raised when an authentication exception occurs during a request. It inherits from BaseError and is used specifically to handle issues related to authentication and login.</p>"},{"location":"#pyecotrend_ista.LoginError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of an authentication error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of an authentication error.\"\"\"\n    return \"An authentication error occurred during the request\"</code></pre>"},{"location":"#pyecotrend_ista.ParserError","title":"ParserError","text":"<p>Exception raised for errors encountered during parsing.</p> <p>This exception is raised when an error occurs during the parsing process of the request response. It inherits from BaseError and can be used to handle issues specifically related to parsing.</p>"},{"location":"#pyecotrend_ista.ParserError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of parser error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of parser error.\"\"\"\n    return \"Error occurred during parsing of the request response\"</code></pre>"},{"location":"#pyecotrend_ista.ServerError","title":"ServerError","text":"<p>Exception raised for server errors during requests.</p> <p>This exception is raised when a exception occurs during a request. It inherits from BaseError  and can be used to handle server-related issues specifically.</p>"},{"location":"#pyecotrend_ista.ServerError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of the error..</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the error..\"\"\"\n    return \"Server error occurred during the request\"</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta","title":"PyEcotrendIsta","text":"<pre><code>PyEcotrendIsta(email: str, password: str, logger: Logger | None = None, hass_dir: str | None = None, totp: str | None = None, session: Session | None = None)</code></pre> <p>A Python client for interacting with the ista EcoTrend API.</p> <p>This class provides methods to authenticate and interact with the ista EcoTrend API.</p> <p>Parameters:</p> <ul> <li> <code>email</code>               (<code>str</code>)           \u2013            <p>The email address used to log in to the ista EcoTrend API.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>The password used to log in to the ista EcoTrend API.</p> </li> <li> <code>logger</code>               (<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional logger instance for logging messages. Default is None.</p> </li> <li> <code>hass_dir</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional directory for Home Assistant configuration. Default is None.</p> </li> <li> <code>totp</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.</p> </li> <li> <code>session</code>               (<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>An optional requests session for making HTTP requests. Default is None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __init__(\n    self,\n    email: str,\n    password: str,\n    logger: logging.Logger | None = None,\n    hass_dir: str | None = None,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n) -&gt; None:\n    \"\"\"Initialize the PyEcotrendIsta client.\n\n    Parameters\n    ----------\n    email : str\n        The email address used to log in to the ista EcoTrend API.\n    password : str\n        The password used to log in to the ista EcoTrend API.\n    logger : logging.Logger, optional\n        [DEPRECATED] An optional logger instance for logging messages. Default is None.\n    hass_dir : str, optional\n        [DEPRECATED] An optional directory for Home Assistant configuration. Default is None.\n    totp : str, optional\n        An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.\n    session : requests.Session, optional\n        An optional requests session for making HTTP requests. Default is None.\n\n    \"\"\"\n\n    if hass_dir:\n        warnings.warn(\n            \"The 'hass_dir' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if logger:\n        warnings.warn(\n            \"The 'logger' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    self._email: str = email.strip()\n    self._password: str = password\n\n    self.loginhelper = LoginHelper(\n        username=self._email,\n        password=self._password,\n        totp=totp,\n        session=session,\n        logger=_LOGGER,\n    )\n\n    self.session: requests.Session = self.loginhelper.session</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.access_token","title":"access_token  <code>property</code> <code>writable</code>","text":"<pre><code>access_token</code></pre> <p>Retrieve the access token, refreshing it if necessary.</p> <p>This property checks if the access token is still valid. If the token has expired and the client is connected, it refreshes the token. The token is considered expired if the current time minus the start time exceeds the token's expiration period.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The current access token.</p> </li> </ul> Notes <p>This method will automatically refresh the access token if it has expired.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__login","title":"__login","text":"<pre><code>__login() -&gt; str | None</code></pre> <p>Perform the login process to obtain an access token.</p> <p>If the email is a demo account, it logs in using a demo user login function. For other accounts, it retrieves a token using a login helper.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __login(self) -&gt; str | None:\n    \"\"\"Perform the login process to obtain an access token.\n\n    If the email is a demo account, it logs in using a demo user login function.\n    For other accounts, it retrieves a token using a login helper.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    \"\"\"\n    if self._email == DEMO_USER_ACCOUNT:\n        _LOGGER.debug(\"Logging in as demo user\")\n        token = self.demo_user_login()\n    else:\n        token = self.loginhelper.get_token()\n    if token:\n        self.access_token = token[\"access_token\"]\n        self._access_token_expires_in = token[\"expires_in\"]\n        self._refresh_token = token[\"refresh_token\"]\n        return self.access_token\n    return None</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__refresh","title":"__refresh","text":"<pre><code>__refresh() -&gt; None</code></pre> <p>Refresh the access token using the refresh token.</p> <p>This method retrieves a new access token, updates internal variables, and resets the token expiration timer.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If there is an authorization failure.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __refresh(self) -&gt; None:\n    \"\"\"Refresh the access token using the refresh token.\n\n    This method retrieves a new access token, updates internal variables,\n    and resets the token expiration timer.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    LoginError\n        If there is an authorization failure.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    \"\"\"\n    (\n        self.access_token,\n        self._access_token_expires_in,\n        self._refresh_token,\n    ) = self.loginhelper.refresh_token(self._refresh_token)\n\n    self._header[\"Authorization\"] = f\"Bearer {self.access_token}\"</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__set_account","title":"__set_account","text":"<pre><code>__set_account() -&gt; None</code></pre> <p>Fetch and set account information from the API.</p> <p>This method performs an API request to retrieve account information, handles various potential errors that might occur during the request, and sets instance variables accordingly using the response data.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the JSON response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If the request fails due to an authorization error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If the request fails due to a server error, timeout, or other request exceptions.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __set_account(self) -&gt; None:\n    \"\"\"Fetch and set account information from the API.\n\n     This method performs an API request to retrieve account information,\n    handles various potential errors that might occur during the request,\n    and sets instance variables accordingly using the response data.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the JSON response.\n    LoginError\n        If the request fails due to an authorization error.\n    ServerError\n        If the request fails due to a server error, timeout, or other request exceptions.\n\n    \"\"\"\n    self._header = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": self.get_user_agent(),\n        \"Authorization\": f\"Bearer {self.access_token}\",\n    }\n    url = f\"{API_BASE_URL}account\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n            r.raise_for_status()\n            try:\n                data = r.json()\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading account information failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading account information failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading account information failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading account information failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading account information failed due to a request exception\") from exc\n\n    self._account = cast(AccountResponse, data)\n    self._uuid = data[\"activeConsumptionUnit\"]</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str</code></pre> <p>Get the version of the PyEcotrendIsta client.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The version number of the PyEcotrendIsta client.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_version(self) -&gt; str:\n    \"\"\"Get the version of the PyEcotrendIsta client.\n\n    Returns\n    -------\n    str\n        The version number of the PyEcotrendIsta client.\n\n    \"\"\"\n    return VERSION</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.login","title":"login","text":"<pre><code>login(force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None</code></pre> <p>Perform the login process if not already connected or forced.</p> <p>Parameters:</p> <ul> <li> <code>force_login</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, forces a fresh login attempt even if already connected. Default is False.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[DEPRECATED] Flag indicating whether to enable debug logging. Default is False.</p> </li> <li> <code>forceLogin</code>               (<code>bool</code>)           \u2013            <p>[DEPRECATED] Use <code>force_login</code> instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the login process fails due to an error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If a server error occurs during login attempts.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal server error occurs during login attempts.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any other unexpected errors during the login process.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def login(self, force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None:\n    \"\"\"Perform the login process if not already connected or forced.\n\n    Parameters\n    ----------\n    force_login : bool, optional\n        If True, forces a fresh login attempt even if already connected. Default is False.\n    debug : bool, optional\n        [DEPRECATED] Flag indicating whether to enable debug logging. Default is False.\n    forceLogin : bool, optional\n        [DEPRECATED] Use `force_login` instead.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    Raises\n    ------\n    LoginError\n        If the login process fails due to an error.\n    ServerError\n        If a server error occurs during login attempts.\n    InternalServerError\n        If an internal server error occurs during login attempts.\n    Exception\n        For any other unexpected errors during the login process.\n\n    \"\"\"\n    if debug:\n        warnings.warn(\n            \"The 'debug' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if \"forceLogin\" in kwargs:\n        warnings.warn(\n            \"The 'forceLogin' keyword parameter is deprecated and will be removed in a future release. \"\n            \"Use force_login instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        force_login = kwargs[\"forceLogin\"]\n\n    if not self._is_connected() or force_login:\n        try:\n            self.__login()\n            self.__set_account()\n        except (KeycloakError, LoginError) as exc:\n            # Login failed\n            self._access_token = None\n            raise LoginError(\n                \"Login failed due to an authorization failure, please verify your email and password\"\n            ) from exc\n        except ServerError as exc:\n            raise ServerError(\"Login failed due to a request exception, please try again later\") from exc\n\n    return self.access_token</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.userinfo","title":"userinfo","text":"<pre><code>userinfo(token)</code></pre> <p>Retrieve user information using the provided access token.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>The access token used for authentication.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>JSON response containing user information.</p> </li> </ul> Notes <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Raises:</p> <ul> <li> <code>RequestException</code>             \u2013            <p>If an error occurs while making the HTTP request.</p> </li> </ul> Example <p>client = PyEcotrendIsta(email='user@example.com', password='password') token = client.login() user_info = client.userinfo(token)</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def userinfo(self, token):\n    \"\"\"Retrieve user information using the provided access token.\n\n    Parameters\n    ----------\n    token : str\n        The access token used for authentication.\n\n    Returns\n    -------\n    Any\n        JSON response containing user information.\n\n    Notes\n    -----\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API.\n    It expects a JSON response with user information.\n\n    Raises\n    ------\n    requests.exceptions.RequestException\n        If an error occurs while making the HTTP request.\n\n    Example\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; token = client.login()\n    &gt;&gt;&gt; user_info = client.userinfo(token)\n\n    \"\"\"\n    return self.loginhelper.userinfo(token=token)</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.logout","title":"logout","text":"<pre><code>logout() -&gt; None</code></pre> <p>Perform logout operation by invalidating the current session.</p> <p>This method invokes the logout functionality in the loginhelper module, passing the current refresh token for session invalidation.</p> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If an error occurs during the logout process. This error is raised based on the response from the logout request.</p> </li> </ul> Example: <p>client = PyEcotrendIsta(email='user@example.com', password='password') client.login() client.logout()</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Perform logout operation by invalidating the current session.\n\n    This method invokes the logout functionality in the loginhelper module,\n    passing the current refresh token for session invalidation.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    Raises\n    ------\n    KeycloakPostError\n        If an error occurs during the logout process. This error is raised based on the response from the logout request.\n\n    Example:\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; client.logout()\n\n    \"\"\"\n    if self.loginhelper.username != DEMO_USER_ACCOUNT:\n        self.loginhelper.logout(self._refresh_token)</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_uuids","title":"get_uuids","text":"<pre><code>get_uuids() -&gt; list[str]</code></pre> <p>Retrieve UUIDs of consumption units registered in the account.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing UUIDs of consumption units. Each UUID represents a consumption unit, which could be a flat or a house for which consumption readings are provided.</p> </li> </ul> Notes <p>A consumption unit represents a residence or building where consumption readings are recorded. The UUIDs are extracted from the <code>_residentAndConsumptionUuidsMap</code> attribute.</p> Example: <p>client = PyEcotrendIsta(email='user@example.com', password='password') client.login() uuids = client.get_uuids() print(uuids) ['uuid1', 'uuid2', 'uuid3']</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_uuids(self) -&gt; list[str]:\n    \"\"\"Retrieve UUIDs of consumption units registered in the account.\n\n    Returns\n    -------\n    list[str]\n        A list containing UUIDs of consumption units. Each UUID represents a consumption unit,\n        which could be a flat or a house for which consumption readings are provided.\n\n    Notes\n    -----\n    A consumption unit represents a residence or building where consumption readings are recorded.\n    The UUIDs are extracted from the `_residentAndConsumptionUuidsMap` attribute.\n\n    Example:\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; uuids = client.get_uuids()\n    &gt;&gt;&gt; print(uuids)\n    ['uuid1', 'uuid2', 'uuid3']\n\n    \"\"\"\n    return list(self._account.get(\"residentAndConsumptionUuidsMap\", {}).values())</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw","title":"consum_raw","text":"<pre><code>consum_raw(select_year: list[int] | None = None, select_month: list[int] | None = None, filter_none: bool = True, obj_uuid: str | None = None) -&gt; dict[str, Any] | ConsumptionsResponse</code></pre> <p>Process consumption and cost data for a given consumption unit.</p> <p>Parameters:</p> <ul> <li> <code>select_year</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of years to filter data by year, default is None.</p> </li> <li> <code>select_month</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of months to filter data by month, default is None.</p> </li> <li> <code>filter_none</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to filter out None values in readings, default is True.</p> </li> <li> <code>obj_uuid</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>UUID of the consumption unit to fetch data for, default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | ConsumptionsResponse</code>           \u2013            <p>Processed data including consumption types, total additional values, last values, last costs, sum by year, and last year compared consumption.</p> </li> </ul> Notes <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an unexpected error during data processing.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def consum_raw(  # noqa: C901\n    self,\n    select_year: list[int] | None = None,\n    select_month: list[int] | None = None,\n    filter_none: bool = True,\n    obj_uuid: str | None = None,\n) -&gt; dict[str, Any] | ConsumptionsResponse:  # noqa: C901\n    \"\"\"Process consumption and cost data for a given consumption unit.\n\n    Parameters\n    ----------\n    select_year : list[int] | None, optional\n        List of years to filter data by year, default is None.\n    select_month : list[int] | None, optional\n        List of months to filter data by month, default is None.\n    filter_none : bool, optional\n        Whether to filter out None values in readings, default is True.\n    obj_uuid : str | None, optional\n        UUID of the consumption unit to fetch data for, default is None.\n\n    Returns\n    -------\n    dict[str, Any] | ConsumptionsResponse\n        Processed data including consumption types, total additional values, last values,\n        last costs, sum by year, and last year compared consumption.\n\n    Notes\n    -----\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Raises\n    ------\n    Exception\n        If there is an unexpected error during data processing.\n\n    \"\"\"\n    # Fetch raw consumption data for the specified UUID\n    c_raw: ConsumptionsResponse = self.get_consumption_data(obj_uuid)\n\n    if not isinstance(c_raw, dict) or (c_raw.get(\"consumptions\") is None and c_raw.get(\"costs\") is None):\n        return c_raw\n\n    if \"consumptions\" not in c_raw or not isinstance(c_raw.get(\"consumptions\"), list):\n        c_raw[\"consumptions\"] = []\n\n    consum_types = []\n    all_dates = []\n    indices_to_delete_consumption = []\n\n    for i, consumption in enumerate(c_raw.get(\"consumptions\", [])):\n        if (\n            not isinstance(consumption, dict)\n            or \"readings\" not in consumption\n            or consumption.get(\"readings\") is None\n            or not isinstance(consumption.get(\"readings\"), list)\n        ):\n            consumption = {}\n            continue\n\n        for reading in consumption.get(\"readings\", []):\n            if reading[\"additionalValue\"] is not None or reading[\"value\"] is not None:\n                consum_types.append(reading[\"type\"])\n\n        consum_types = list({consum_type for consum_type in consum_types if i is not None})\n\n        new_readings = []\n        if \"date\" in consumption:\n            all_dates.append(consumption[\"date\"])\n        if select_month is None and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif (\n            select_year is not None\n            and select_month is not None\n            and consumption[\"date\"][\"year\"] in select_year\n            and consumption[\"date\"][\"month\"] in select_month\n        ):\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_year is not None and consumption[\"date\"][\"year\"] in select_year and select_month is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_month is not None and consumption[\"date\"][\"month\"] in select_month and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        if new_readings:\n            consumption[\"readings\"] = new_readings\n        else:\n            indices_to_delete_consumption.append(i)\n\n    for index in sorted(indices_to_delete_consumption, reverse=True):\n        if index &lt; len(c_raw[\"consumptions\"]):\n            del c_raw[\"consumptions\"][index]\n\n    _all_date = all_dates\n    new_date = []\n    sum_by_year = {}\n    for date in _all_date:\n        if select_year is None or date[\"year\"] in select_year:\n            new_date.append(date[\"year\"])\n    new_date = list(dict.fromkeys(new_date))\n\n    cost_consum_types = consum_types\n\n    sum_by_year = {typ: {year: 0.0 for year in new_date} for typ in cost_consum_types}\n\n    for item in c_raw.get(\"consumptions\", []):\n        if \"readings\" not in item or not item[\"readings\"]:\n            continue\n        for reading in item.get(\"readings\", []):\n            if reading.get(\"type\", None) is None:\n                continue\n            for typ in cost_consum_types:\n                for year in new_date:\n                    if reading[\"type\"] == typ and item[\"date\"][\"year\"] == year:\n                        if reading[\"value\"]:\n                            sum_by_year[typ][year] += round(\n                                float(reading[\"value\"].replace(\",\", \".\")),\n                                1,\n                            )\n                        else:\n                            sum_by_year[typ][year] += round(\n                                (\n                                    float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                                    if reading[\"additionalValue\"] is not None\n                                    else 0.0\n                                ),\n                                1,\n                            )\n\n                        if reading[\"type\"] == \"warmwater\":\n                            sum_by_year[\"ww\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"water\":\n                            sum_by_year[\"w\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                            sum_by_year[\"h\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\":\n                            sum_by_year[\"h\"] = reading[\"additionalUnit\"]\n\n    indices_to_delete_costs = []\n\n    if \"costs\" not in c_raw or not isinstance(c_raw.get(\"costs\"), list):\n        c_raw[\"costs\"] = []\n\n    for i, costs in enumerate(c_raw.get(\"costs\", [])):\n        new_readings = []\n        if \"costsByEnergyType\" in costs:\n            if select_month is None and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif (\n                select_year is not None\n                and select_month is not None\n                and costs[\"date\"][\"year\"] in select_year\n                and costs[\"date\"][\"month\"] in select_month\n            ):\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_year is not None and costs[\"date\"][\"year\"] in select_year and select_month is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_month is not None and costs[\"date\"][\"month\"] in select_month and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n        if new_readings:\n            costs[\"costsByEnergyType\"] = new_readings\n        else:\n            indices_to_delete_costs.append(i)\n    for index in sorted(indices_to_delete_costs, reverse=True):\n        if \"costs\" in c_raw and index &lt; len(c_raw[\"costs\"]):\n            del c_raw[\"costs\"][index]\n\n    for key in [\n        \"consumptionsBillingPeriods\",\n        \"costsBillingPeriods\",\n        \"resident\",\n        \"co2Emissions\",\n        \"co2EmissionsBillingPeriods\",\n    ]:\n        if key in c_raw:\n            del c_raw[key]\n\n    consumptions: list = c_raw.get(\"consumptions\", [])\n    costs: list = c_raw.get(\"costs\", [])\n\n    combined_data = []\n    for cost_entry in costs:\n        for consumption_entry in consumptions:\n            # \u00dcberpr\u00fcfen, ob die Daten das gleiche Datum haben\n            if cost_entry[\"date\"] == consumption_entry[\"date\"]:\n                # Wenn ja, kombiniere die Kosten- und Verbrauchsdaten in einem Eintrag\n                combined_entry = {\n                    \"date\": cost_entry[\"date\"],\n                    \"consumptions\": consumption_entry[\"readings\"],\n                    \"costs\": cost_entry[\"costsByEnergyType\"],\n                }\n\n                combined_data.append(combined_entry)\n\n    total_additional_values = {}\n    total_additional_custom_values = {}\n    for consumption_unit in consumptions:\n        if \"readings\" not in consumption_unit or not consumption_unit[\"readings\"]:\n            continue\n        for reading in consumption_unit.get(\"readings\", []):\n            if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                continue\n\n            if reading[\"type\"] not in total_additional_custom_values:\n                total_additional_custom_values[reading[\"type\"]] = 0.0\n            if reading[\"additionalValue\"]:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    float(reading[\"additionalValue\"].replace(\",\", \".\")), 1\n                )\n            else:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    (float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_custom_values[\"ww\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_custom_values[\"w\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                total_additional_custom_values[\"h\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_custom_values[\"h\"] = reading[\"unit\"]\n\n            if reading[\"type\"] not in total_additional_values:\n                total_additional_values[reading[\"type\"]] = 0.0\n            if reading[\"value\"]:\n                total_additional_values[reading[\"type\"]] += round(float(reading[\"value\"].replace(\",\", \".\")), 1)\n            else:\n                total_additional_values[reading[\"type\"]] += round(\n                    (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    ),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_values[\"ww\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_values[\"w\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                total_additional_values[\"h\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_values[\"h\"] = reading[\"additionalUnit\"]\n\n    last_value = None\n    last_custom_value = None\n    last_year_compared_consumption = None\n\n    if consumptions:\n        last_value = {}\n        last_custom_value = {}\n        last_year_compared_consumption = {}\n\n        if len(consumptions) &gt; 0 and \"readings\" in consumptions[0] and consumptions[0][\"readings\"]:\n            for reading in consumptions[0][\"readings\"]:\n                if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                    continue\n\n                if reading[\"comparedConsumption\"]:\n                    last_year_compared_consumption[reading[\"type\"]] = reading[\"comparedConsumption\"]\n                    last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"] = float(\n                        last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"].replace(\",\", \".\")\n                    )\n\n                    if reading[\"value\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"value\"].replace(\",\", \".\")\n                        )\n                    elif reading[\"additionalValue\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"additionalValue\"].replace(\",\", \".\")\n                        )\n                    if \"period\" in last_year_compared_consumption[reading[\"type\"]]:\n                        del last_year_compared_consumption[reading[\"type\"]][\"period\"]\n\n                if reading[\"type\"] not in last_custom_value:\n                    last_custom_value[reading[\"type\"]] = 0.0\n                if reading[\"additionalValue\"]:\n                    last_custom_value[reading[\"type\"]] += float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                else:\n                    last_custom_value[reading[\"type\"]] += (\n                        float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0\n                    )\n\n                if reading[\"type\"] == \"warmwater\":\n                    last_custom_value[\"ww\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_custom_value[\"w\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_custom_value[\"h\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_custom_value[\"h\"] = reading[\"unit\"]\n\n                if reading[\"type\"] not in last_value:\n                    last_value[reading[\"type\"]] = 0.0\n                if reading[\"value\"]:  # reading[\"type\"] in (\"warmwater\", \"water\", \"heating\") and\n                    last_value[reading[\"type\"]] += float(reading[\"value\"].replace(\",\", \".\"))\n                else:\n                    last_value[reading[\"type\"]] += (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    )\n                if reading[\"type\"] == \"warmwater\":\n                    last_value[\"ww\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_value[\"w\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_value[\"h\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_value[\"h\"] = reading[\"additionalUnit\"]\n\n        last_custom_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_custom_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n        last_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n    last_costs = None\n    if costs:\n        if last_costs is None:\n            last_costs = {}\n        for costs_by_energy_type in costs[0][\"costsByEnergyType\"]:\n            if (\n                costs_by_energy_type is None\n                or \"type\" not in costs_by_energy_type\n                or costs_by_energy_type[\"type\"] is None\n                or \"comparedCost\" not in costs_by_energy_type\n                or costs_by_energy_type[\"comparedCost\"] is None\n                or \"smiley\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"smiley\"] is None\n                or \"comparedPercentage\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] is None\n            ):\n                continue\n\n            if costs_by_energy_type[\"type\"] not in last_costs:\n                last_costs[costs_by_energy_type[\"type\"]] = 0.0\n            last_costs[costs_by_energy_type[\"type\"]] += costs_by_energy_type[\"value\"]\n            last_costs[\"unit\"] = costs_by_energy_type[\"unit\"]\n            if costs_by_energy_type[\"type\"] == \"warmwater\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"water\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"heating\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n        last_costs[\"month\"] = costs[0][\"date\"][\"month\"]\n        last_costs[\"year\"] = costs[0][\"date\"][\"year\"]\n\n    return CustomRaw.from_dict(\n        {\n            \"consum_types\": consum_types,\n            \"combined_data\": None,  # combined_data,\n            \"total_additional_values\": total_additional_values,\n            \"total_additional_custom_values\": total_additional_custom_values,\n            \"last_value\": last_value,\n            \"last_custom_value\": last_custom_value,\n            \"last_costs\": last_costs,\n            \"all_dates\": None,  # all_dates,\n            \"sum_by_year\": sum_by_year,\n            \"last_year_compared_consumption\": last_year_compared_consumption,\n        }\n    ).to_dict()</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_consumption_data","title":"get_consumption_data","text":"<pre><code>get_consumption_data(obj_uuid: str | None = None) -&gt; ConsumptionsResponse</code></pre> <p>Fetch consumption data from the API for a specific consumption unit.</p> <p>Parameters:</p> <ul> <li> <code>obj_uuid</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The UUID of the consumption unit. If not provided, defaults to the UUID associated with the instance (<code>self._uuid</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A dictionary containing the consumption data fetched from the API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an error indicating authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the provided UUID is invalid.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_data(self, obj_uuid: str | None = None) -&gt; ConsumptionsResponse:\n    \"\"\"Fetch consumption data from the API for a specific consumption unit.\n\n    Parameters\n    ----------\n    obj_uuid : str, optional\n        The UUID of the consumption unit. If not provided,\n        defaults to the UUID associated with the instance (`self._uuid`).\n\n    Returns\n    -------\n    ConsumptionsResponse\n        A dictionary containing the consumption data fetched from the API.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an error indicating authorization failure.\n    ParserError\n        If there is an error parsing the request response.\n    ValueError\n        If the provided UUID is invalid.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n\n    params = {\n        \"consumptionUnitUuid\": obj_uuid or self._uuid\n    }\n    url = f\"{API_BASE_URL}consumptions\"\n    try:\n        with self.session.get(url, params=params, headers=self._header, ) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text[:100])\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption data failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption data failed failed due to an authorization failure\") from exc\n        if exc.response.status_code == HTTPStatus.BAD_REQUEST:\n            raise ValueError(\n                f\"Invalid UUID. Retrieving data for consumption unit {obj_uuid or self._uuid} failed\"\n            ) from exc\n        raise ServerError(\n            \"Loading consumption data failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption data failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption data failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_consumption_unit_details","title":"get_consumption_unit_details","text":"<pre><code>get_consumption_unit_details() -&gt; ConsumptionUnitDetailsResponse</code></pre> <p>Retrieve details of the consumption unit from the API.</p> <p>Returns:</p> <ul> <li> <code>ConsumptionUnitDetailsResponse</code>           \u2013            <p>A dictionary containing the details of the consumption unit.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an issue with decoding the JSON response</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_unit_details(self) -&gt; ConsumptionUnitDetailsResponse:\n    \"\"\"Retrieve details of the consumption unit from the API.\n\n    Returns\n    -------\n    ConsumptionUnitDetailsResponse\n        A dictionary containing the details of the consumption unit.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an authorization failure.\n    ParserError\n        If there is an issue with decoding the JSON response\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n    url = f\"{API_BASE_URL}menu\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionUnitDetailsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption unit details failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption unit details failed failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading consumption unit details failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption unit details failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption unit details failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_support_code","title":"get_support_code","text":"<pre><code>get_support_code() -&gt; str | None</code></pre> <p>Return the support code associated with the instance.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The support code associated with the instance, or None if not set.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_support_code(self) -&gt; str | None:\n    \"\"\"Return the support code associated with the instance.\n\n    Returns\n    -------\n    str or None\n        The support code associated with the instance, or None if not set.\n\n    \"\"\"\n    return getattr(self, \"_account\", {}).get(\"supportCode\")</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_user_agent","title":"get_user_agent","text":"<pre><code>get_user_agent() -&gt; str</code></pre> <p>Return the User-Agent string used for HTTP requests.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The User-Agent string.</p> </li> </ul> Notes <p>This method provides a static User-Agent string commonly used for web browsers.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_user_agent(self) -&gt; str:\n    \"\"\"Return the User-Agent string used for HTTP requests.\n\n    Returns\n    -------\n    str\n        The User-Agent string.\n\n    Notes\n    -----\n    This method provides a static User-Agent string commonly used for web browsers.\n\n    \"\"\"\n    return (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67\"\n        \" Safari/537.36\"\n    )</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.demo_user_login","title":"demo_user_login","text":"<pre><code>demo_user_login() -&gt; GetTokenResponse</code></pre> <p>Retrieve authentication tokens for the demo user.</p> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def demo_user_login(self) -&gt; GetTokenResponse:\n    \"\"\"Retrieve authentication tokens for the demo user.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n    url = f\"{API_BASE_URL}demo-user-token\"\n    try:\n        self._header[\"User-Agent\"] = self.get_user_agent()\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                data = r.json()\n                key = iter(GetTokenResponse.__annotations__)\n                token = {next(key): value for value in data.values()}\n                return cast(GetTokenResponse, token)\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Demo user authentication failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        raise ServerError(\n            \"Demo user authentication failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Demo user authentication failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Demo user authentication failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_account","title":"get_account","text":"<pre><code>get_account() -&gt; AccountResponse | None</code></pre> <p>Retrieve the account information.</p> <p>Returns the <code>_account</code> attribute if it exists, otherwise returns None.</p> <p>Returns:</p> <ul> <li> <code>AccountResponse | None</code>           \u2013            <p>Account information if available, otherwise None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_account(self) -&gt; AccountResponse | None:\n    \"\"\"Retrieve the account information.\n\n    Returns the `_account` attribute if it exists, otherwise returns None.\n\n    Returns\n    -------\n    AccountResponse | None\n        Account information if available, otherwise None.\n\n    \"\"\"\n    return getattr(self, \"_account\", None)</code></pre>"},{"location":"#pyecotrend_ista.ConsumptionsResponse","title":"ConsumptionsResponse","text":"<p>A TypedDict representing the response structure for consumption data.</p> <p>Attributes:</p> <ul> <li> <code>co2Emissions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different periods.</p> </li> <li> <code>co2EmissionsBillingPeriods</code>               (<code>list[IstaBillingPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different billing periods.</p> </li> <li> <code>consumptionUnitId</code>               (<code>str</code>)           \u2013            <p>The unique identifier for the consumption unit.</p> </li> <li> <code>consumptions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of consumption data over different periods.</p> </li> <li> <code>consumptionsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The consumption data over different billing periods.</p> </li> <li> <code>costs</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of cost data over different periods.</p> </li> <li> <code>costsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The cost data over different billing periods.</p> </li> <li> <code>isSCEedBasicForCurrentMonth</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the current month.</p> </li> <li> <code>nonEEDBasicStartDate</code>               (<code>Any</code>)           \u2013            <p>The start date for non-EED basic plan (data type unknown).</p> </li> <li> <code>resident</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary containing resident information.</p> </li> </ul>"},{"location":"exception_classes/","title":"Exceptions","text":""},{"location":"exception_classes/#pyecotrend_ista.exception_classes","title":"pyecotrend_ista.exception_classes","text":"<p>Exception Class.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.BaseError","title":"BaseError","text":"<p>Base class for exceptions in this module.</p> <p>This is the base class for all custom exceptions in the module. It inherits from Python's built-in Exception class and can be used to catch errors specific to this module.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ServerError","title":"ServerError","text":"<p>Exception raised for server errors during requests.</p> <p>This exception is raised when a exception occurs during a request. It inherits from BaseError  and can be used to handle server-related issues specifically.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ServerError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of the error..</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the error..\"\"\"\n    return \"Server error occurred during the request\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.LoginError","title":"LoginError","text":"<p>Exception raised for login- and authentication related errors.</p> <p>This exception is raised when an authentication exception occurs during a request. It inherits from BaseError and is used specifically to handle issues related to authentication and login.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.LoginError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of an authentication error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of an authentication error.\"\"\"\n    return \"An authentication error occurred during the request\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ParserError","title":"ParserError","text":"<p>Exception raised for errors encountered during parsing.</p> <p>This exception is raised when an error occurs during the parsing process of the request response. It inherits from BaseError and can be used to handle issues specifically related to parsing.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ParserError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of parser error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of parser error.\"\"\"\n    return \"Error occurred during parsing of the request response\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError","title":"KeycloakError","text":"<pre><code>KeycloakError(error_message='', response_code=None, response_body=None)</code></pre> <p>Base class for custom Keycloak errors.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The response status code :type response_code: int</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>:returns: String representation of the object :rtype: str</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    :returns: String representation of the object\n    :rtype: str\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    else:\n        return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError","title":"KeycloakAuthenticationError","text":"<pre><code>KeycloakAuthenticationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak authentication error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError","title":"KeycloakOperationError","text":"<pre><code>KeycloakOperationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak operation error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError","title":"KeycloakGetError","text":"<pre><code>KeycloakGetError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request get error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError","title":"KeycloakPostError","text":"<pre><code>KeycloakPostError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request post error exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound","title":"KeycloakCodeNotFound","text":"<pre><code>KeycloakCodeNotFound(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak Code not found exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError","title":"KeycloakInvalidTokenError","text":"<pre><code>KeycloakInvalidTokenError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak invalid token exception.</p> <p>:param error_message: The error message :type error_message: str :param response_code: The code of the response :type response_code: int :param response_body: Body of the response :type response_body: bytes</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):\n    \"\"\"Init method.\n\n    :param error_message: The error message\n    :type error_message: str\n    :param response_code: The code of the response\n    :type response_code: int\n    :param response_body: Body of the response\n    :type response_body: bytes\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.deprecated","title":"deprecated","text":"<pre><code>deprecated(func: Callable[..., T], alias_func: str | None = None) -&gt; Callable[..., T]</code></pre> <p>Decorate a function as deprecated and emit a warning when called.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable[..., T]</code>)           \u2013            <p>The function to be marked as deprecated.</p> </li> <li> <code>alias_func</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The real function name to show as deprecated, in case the function was called through an alias.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[..., T]</code>           \u2013            <p>A wrapper function that emits a deprecation warning when called.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def deprecated(func: Callable[..., T], alias_func: str | None = None) -&gt; Callable[..., T]:\n    \"\"\"Decorate a function as deprecated and emit a warning when called.\n\n    Parameters\n    ----------\n    func: Callable[..., T])\n        The function to be marked as deprecated.\n    alias_func : str, optional\n        The real function name to show as deprecated, in case the function was called\n        through an alias.\n\n\n    Returns\n    -------\n    Callable[..., T]\n        A wrapper function that emits a deprecation warning when called.\n\n    \"\"\"\n\n    def deprecated_func(*args, **kwargs):\n        if alias_func:\n            warning_message = (\n                f\"The `{alias_func}` function is deprecated and will be removed in a future release. \"\n                f\"Use `{func.__name__}` instead.\"\n            )\n        else:\n            warning_message = f\"The `{func.__name__}` function is deprecated and will be removed in a future release.\"\n\n        warnings.warn(warning_message, category=DeprecationWarning, stacklevel=2)\n        return func(*args, **kwargs)\n\n    return deprecated_func</code></pre>"},{"location":"login_helper/","title":"Login Helper","text":""},{"location":"login_helper/#pyecotrend_ista.login_helper","title":"pyecotrend_ista.login_helper","text":"<p>Login helper for Keycloak.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper","title":"LoginHelper","text":"<pre><code>LoginHelper(username: str, password: str, totp: str | None = None, session: Session | None = None, logger=None)</code></pre> <p>Login helper for Keycloak.</p> <p>Attributes:</p> <ul> <li> <code>session</code>               (<code>Session</code>)           \u2013            <p>Optional session object for making HTTP requests.</p> </li> <li> <code>username</code>               (<code>str</code>)           \u2013            <p>Username for authentication.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>Password for authentication.</p> </li> <li> <code>cookie</code>               (<code>str</code>)           \u2013            <p>Authentication cookie.</p> </li> <li> <code>auth_code</code>               (<code>str</code>)           \u2013            <p>Authorization code.</p> </li> <li> <code>form_action</code>               (<code>str</code>)           \u2013            <p>Form action URL for authentication.</p> </li> </ul> Notes <p>This class provides utility methods for handling authentication and session management using Keycloak.</p> <p>Parameters:</p> <ul> <li> <code>username</code>               (<code>str</code>)           \u2013            <p>Username for authentication.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>Password for authentication.</p> </li> <li> <code>totp</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Time-based One-Time Password if enabled, by default None.</p> </li> <li> <code>session</code>               (<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>Optional session object for making HTTP requests, by default None.</p> </li> <li> <code>logger</code>               (<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>Logger object for logging messages, by default None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n    logger=None,\n) -&gt; None:\n    \"\"\"Initialize the object with username and password.\n\n    Parameters\n    ----------\n    username : str\n        Username for authentication.\n    password : str\n        Password for authentication.\n    totp : str, optional\n        Time-based One-Time Password if enabled, by default None.\n    session : requests.Session, optional\n        Optional session object for making HTTP requests, by default None.\n    logger : logging.Logger, optional\n        Logger object for logging messages, by default None.\n\n    \"\"\"\n    self.username: str = username\n    self.password: str = password\n    self.totp: str | None = totp\n\n    self.session = session or requests.Session()\n\n    self.session.verify = True\n    retries = Retry(total=5, backoff_factor=1, status_forcelist=[502, 503, 504, 408])\n    self.session.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\n    self.logger = logger or logging.getLogger(__name__)</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.refresh_token","title":"refresh_token","text":"<pre><code>refresh_token(refresh_token) -&gt; tuple</code></pre> <p>Refresh the access token using the provided refresh token.</p> <p>Parameters:</p> <ul> <li> <code>refresh_token</code>               (<code>str</code>)           \u2013            <p>The refresh token obtained from previous authentication.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, int, str]</code>           \u2013            <p>Tuple containing the refreshed access token, its expiration time in seconds, and the new refresh token.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def refresh_token(self, refresh_token) -&gt; tuple:\n    \"\"\"Refresh the access token using the provided refresh token.\n\n    Parameters\n    ----------\n    refresh_token : str\n        The refresh token obtained from previous authentication.\n\n    Returns\n    -------\n    tuple[str, int, str]\n        Tuple containing the refreshed access token, its expiration time in seconds,\n        and the new refresh token.\n    \"\"\"\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}token\",\n        data={\n            \"grant_type\": GRANT_TYPE_REFRESH_TOKEN,\n            \"client_id\": CLIENT_ID,  # ecotrend\n            \"refresh_token\": refresh_token,\n        },\n    )\n\n    result = resp.json()\n\n    return result[\"access_token\"], result[\"expires_in\"], result[\"refresh_token\"]</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.get_token","title":"get_token","text":"<pre><code>get_token() -&gt; GetTokenResponse</code></pre> <p>Retrieve access and refresh tokens using the obtained authorization code.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If there's an error during the POST request to retrieve tokens.</p> </li> <li> <code>KeycloakInvalidTokenError</code>             \u2013            <p>If the response status code is not 200, indicating an invalid token.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def get_token(self) -&gt; GetTokenResponse:\n    \"\"\"Retrieve access and refresh tokens using the obtained authorization code.\n\n    Raises\n    ------\n    KeycloakPostError\n        If there's an error during the POST request to retrieve tokens.\n\n    KeycloakInvalidTokenError\n        If the response status code is not 200, indicating an invalid token.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    \"\"\"\n    self._login()\n    _data = {\n        \"grant_type\": GRANT_TYPE_AUTHORIZATION_CODE,\n        \"client_id\": CLIENT_ID,  # ecotrend\n        \"redirect_uri\": REDIRECT_URI,\n        \"code\": self.auth_code,\n    }\n    if self.totp:\n        _data[\"totp\"] = self.totp\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}token\",\n        data=_data,\n        timeout=TIMEOUT,\n        allow_redirects=False,\n    )\n\n    raise_error_from_response(response=resp, error=KeycloakPostError)\n    # If the response code is not 200 raise an exception.\n    if resp.status_code != 200:\n        raise KeycloakInvalidTokenError()\n\n    return cast(GetTokenResponse, resp.json())</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.userinfo","title":"userinfo","text":"<pre><code>userinfo(token) -&gt; Any</code></pre> <p>Retrieve user information from the Keycloak provider.</p> <p>This method sends a GET request to the Keycloak <code>userinfo</code> endpoint using the provided token in the Authorization header. It returns the JSON response containing user information.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>The access token to be used for authorization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A dictionary containing the user information if the request is successful, or an empty dictionary if the user is a demo user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakOperationError</code>             \u2013            <p>If the request fails due to a Keycloak operation error.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def userinfo(self, token) -&gt; Any:\n    \"\"\"Retrieve user information from the Keycloak provider.\n\n    This method sends a GET request to the Keycloak `userinfo` endpoint using the provided\n    token in the Authorization header. It returns the JSON response containing user information.\n\n    Parameters\n    ----------\n    token : str\n        The access token to be used for authorization.\n\n    Returns\n    -------\n    Any\n        A dictionary containing the user information if the request is successful, or an empty\n        dictionary if the user is a demo user.\n\n    Raises\n    ------\n    KeycloakOperationError\n        If the request fails due to a Keycloak operation error.\n    \"\"\"\n    if self.username == DEMO_USER_ACCOUNT:\n        return {}\n\n    header = {\"Authorization\": f\"Bearer {token}\"}\n    url = f\"{PROVIDER_URL}userinfo\"\n\n    resp: requests.Response = self._send_request(\"GET\", url=url, headers=header)\n\n    return resp.json()</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.logout","title":"logout","text":"<pre><code>logout(token) -&gt; dict | Any | bytes | dict[str, str]</code></pre> <p>Log out the user session from the identity provider.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Refresh token associated with the user session.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[dict, Any, bytes, dict[str, str]]</code>           \u2013            <p>Response data from the logout request. The exact type may vary based on the response content.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If an error occurs during the POST request to logout the user.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def logout(self, token) -&gt; dict | Any | bytes | dict[str, str]:\n    \"\"\"Log out the user session from the identity provider.\n\n    Parameters\n    ----------\n    token : str\n        Refresh token associated with the user session.\n\n    Returns\n    -------\n    Union[dict, Any, bytes, dict[str, str]]\n        Response data from the logout request. The exact type may vary based on the response content.\n\n    Raises\n    ------\n    KeycloakPostError\n        If an error occurs during the POST request to logout the user.\n\n    \"\"\"\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}logout\",\n        data={\n            \"client_id\": CLIENT_ID,\n            \"refresh_token\": token,\n        },\n    )\n\n    return raise_error_from_response(resp, KeycloakPostError)</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response","title":"raise_error_from_response","text":"<pre><code>raise_error_from_response(response: Response, error, expected_codes=None, skip_exists=False) -&gt; dict | Any | bytes | dict[str, str]</code></pre> <p>Raise an exception for the response.</p> <p>Parameters:</p> <ul> <li> <code>response</code>               (<code>Response</code>)           \u2013            <p>The response object.</p> </li> <li> <code>error</code>               (<code>dict or Exception</code>)           \u2013            <p>Error object to raise.</p> </li> <li> <code>expected_codes</code>               (<code>Sequence[int]</code>, default:                   <code>None</code> )           \u2013            <p>Set of expected codes, which should not raise the exception.</p> </li> <li> <code>skip_exists</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates whether the response on already existing object should be ignored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes or dict</code>           \u2013            <p>Content of the response message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakError</code>             \u2013            <p>In case of unexpected status codes.</p> </li> </ul> Notes <p>Source from https://github.com/marcospereirampj/python-keycloak/blob/c98189ca6951f12f1023ed3370c9aaa0d81e4aa4/src/keycloak/exceptions.py</p> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def raise_error_from_response(\n    response: requests.Response, error, expected_codes=None, skip_exists=False\n) -&gt; dict | Any | bytes | dict[str, str]:\n    \"\"\"Raise an exception for the response.\n\n    Parameters\n    ----------\n    response : Response\n        The response object.\n    error : dict or Exception\n        Error object to raise.\n    expected_codes : Sequence[int], optional\n        Set of expected codes, which should not raise the exception.\n    skip_exists : bool, optional\n        Indicates whether the response on already existing object should be ignored.\n\n    Returns\n    -------\n    bytes or dict\n        Content of the response message.\n\n    Raises\n    ------\n    KeycloakError\n        In case of unexpected status codes.\n\n    Notes\n    -----\n    Source from https://github.com/marcospereirampj/python-keycloak/blob/c98189ca6951f12f1023ed3370c9aaa0d81e4aa4/src/keycloak/exceptions.py\n    \"\"\"  # noqa: DAR401,DAR402\n    if expected_codes is None:\n        expected_codes = [200, 201, 204]\n\n    if response.status_code in expected_codes:\n        if response.status_code == requests.codes[\"no_content\"]:\n            return {}\n\n        try:\n            return response.json()\n        except ValueError:\n            return response.content\n\n    if skip_exists and response.status_code == 409:\n        return {\"msg\": \"Already exists\"}\n\n    try:\n        message = response.json()[\"message\"]\n    except (KeyError, ValueError):\n        message = response.content\n\n    if isinstance(error, dict):\n        error = error.get(response.status_code, KeycloakOperationError)\n    else:\n        if response.status_code == 401:\n            error = KeycloakAuthenticationError\n\n    raise error(error_message=message, response_code=response.status_code, response_body=response.content)</code></pre>"},{"location":"pyecotrend_ista/","title":"API documentation","text":""},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta","title":"pyecotrend_ista.PyEcotrendIsta","text":"<pre><code>PyEcotrendIsta(email: str, password: str, logger: Logger | None = None, hass_dir: str | None = None, totp: str | None = None, session: Session | None = None)</code></pre> <p>A Python client for interacting with the ista EcoTrend API.</p> <p>This class provides methods to authenticate and interact with the ista EcoTrend API.</p> <p>Parameters:</p> <ul> <li> <code>email</code>               (<code>str</code>)           \u2013            <p>The email address used to log in to the ista EcoTrend API.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>The password used to log in to the ista EcoTrend API.</p> </li> <li> <code>logger</code>               (<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional logger instance for logging messages. Default is None.</p> </li> <li> <code>hass_dir</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional directory for Home Assistant configuration. Default is None.</p> </li> <li> <code>totp</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.</p> </li> <li> <code>session</code>               (<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>An optional requests session for making HTTP requests. Default is None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __init__(\n    self,\n    email: str,\n    password: str,\n    logger: logging.Logger | None = None,\n    hass_dir: str | None = None,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n) -&gt; None:\n    \"\"\"Initialize the PyEcotrendIsta client.\n\n    Parameters\n    ----------\n    email : str\n        The email address used to log in to the ista EcoTrend API.\n    password : str\n        The password used to log in to the ista EcoTrend API.\n    logger : logging.Logger, optional\n        [DEPRECATED] An optional logger instance for logging messages. Default is None.\n    hass_dir : str, optional\n        [DEPRECATED] An optional directory for Home Assistant configuration. Default is None.\n    totp : str, optional\n        An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.\n    session : requests.Session, optional\n        An optional requests session for making HTTP requests. Default is None.\n\n    \"\"\"\n\n    if hass_dir:\n        warnings.warn(\n            \"The 'hass_dir' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if logger:\n        warnings.warn(\n            \"The 'logger' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    self._email: str = email.strip()\n    self._password: str = password\n\n    self.loginhelper = LoginHelper(\n        username=self._email,\n        password=self._password,\n        totp=totp,\n        session=session,\n        logger=_LOGGER,\n    )\n\n    self.session: requests.Session = self.loginhelper.session</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.access_token","title":"access_token  <code>property</code> <code>writable</code>","text":"<pre><code>access_token</code></pre> <p>Retrieve the access token, refreshing it if necessary.</p> <p>This property checks if the access token is still valid. If the token has expired and the client is connected, it refreshes the token. The token is considered expired if the current time minus the start time exceeds the token's expiration period.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The current access token.</p> </li> </ul> Notes <p>This method will automatically refresh the access token if it has expired.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__login","title":"__login","text":"<pre><code>__login() -&gt; str | None</code></pre> <p>Perform the login process to obtain an access token.</p> <p>If the email is a demo account, it logs in using a demo user login function. For other accounts, it retrieves a token using a login helper.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __login(self) -&gt; str | None:\n    \"\"\"Perform the login process to obtain an access token.\n\n    If the email is a demo account, it logs in using a demo user login function.\n    For other accounts, it retrieves a token using a login helper.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    \"\"\"\n    if self._email == DEMO_USER_ACCOUNT:\n        _LOGGER.debug(\"Logging in as demo user\")\n        token = self.demo_user_login()\n    else:\n        token = self.loginhelper.get_token()\n    if token:\n        self.access_token = token[\"access_token\"]\n        self._access_token_expires_in = token[\"expires_in\"]\n        self._refresh_token = token[\"refresh_token\"]\n        return self.access_token\n    return None</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__refresh","title":"__refresh","text":"<pre><code>__refresh() -&gt; None</code></pre> <p>Refresh the access token using the refresh token.</p> <p>This method retrieves a new access token, updates internal variables, and resets the token expiration timer.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If there is an authorization failure.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __refresh(self) -&gt; None:\n    \"\"\"Refresh the access token using the refresh token.\n\n    This method retrieves a new access token, updates internal variables,\n    and resets the token expiration timer.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    LoginError\n        If there is an authorization failure.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    \"\"\"\n    (\n        self.access_token,\n        self._access_token_expires_in,\n        self._refresh_token,\n    ) = self.loginhelper.refresh_token(self._refresh_token)\n\n    self._header[\"Authorization\"] = f\"Bearer {self.access_token}\"</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__set_account","title":"__set_account","text":"<pre><code>__set_account() -&gt; None</code></pre> <p>Fetch and set account information from the API.</p> <p>This method performs an API request to retrieve account information, handles various potential errors that might occur during the request, and sets instance variables accordingly using the response data.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the JSON response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If the request fails due to an authorization error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If the request fails due to a server error, timeout, or other request exceptions.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __set_account(self) -&gt; None:\n    \"\"\"Fetch and set account information from the API.\n\n     This method performs an API request to retrieve account information,\n    handles various potential errors that might occur during the request,\n    and sets instance variables accordingly using the response data.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the JSON response.\n    LoginError\n        If the request fails due to an authorization error.\n    ServerError\n        If the request fails due to a server error, timeout, or other request exceptions.\n\n    \"\"\"\n    self._header = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": self.get_user_agent(),\n        \"Authorization\": f\"Bearer {self.access_token}\",\n    }\n    url = f\"{API_BASE_URL}account\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n            r.raise_for_status()\n            try:\n                data = r.json()\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading account information failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading account information failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading account information failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading account information failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading account information failed due to a request exception\") from exc\n\n    self._account = cast(AccountResponse, data)\n    self._uuid = data[\"activeConsumptionUnit\"]</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str</code></pre> <p>Get the version of the PyEcotrendIsta client.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The version number of the PyEcotrendIsta client.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_version(self) -&gt; str:\n    \"\"\"Get the version of the PyEcotrendIsta client.\n\n    Returns\n    -------\n    str\n        The version number of the PyEcotrendIsta client.\n\n    \"\"\"\n    return VERSION</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.login","title":"login","text":"<pre><code>login(force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None</code></pre> <p>Perform the login process if not already connected or forced.</p> <p>Parameters:</p> <ul> <li> <code>force_login</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, forces a fresh login attempt even if already connected. Default is False.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[DEPRECATED] Flag indicating whether to enable debug logging. Default is False.</p> </li> <li> <code>forceLogin</code>               (<code>bool</code>)           \u2013            <p>[DEPRECATED] Use <code>force_login</code> instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the login process fails due to an error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If a server error occurs during login attempts.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal server error occurs during login attempts.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any other unexpected errors during the login process.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def login(self, force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None:\n    \"\"\"Perform the login process if not already connected or forced.\n\n    Parameters\n    ----------\n    force_login : bool, optional\n        If True, forces a fresh login attempt even if already connected. Default is False.\n    debug : bool, optional\n        [DEPRECATED] Flag indicating whether to enable debug logging. Default is False.\n    forceLogin : bool, optional\n        [DEPRECATED] Use `force_login` instead.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    Raises\n    ------\n    LoginError\n        If the login process fails due to an error.\n    ServerError\n        If a server error occurs during login attempts.\n    InternalServerError\n        If an internal server error occurs during login attempts.\n    Exception\n        For any other unexpected errors during the login process.\n\n    \"\"\"\n    if debug:\n        warnings.warn(\n            \"The 'debug' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if \"forceLogin\" in kwargs:\n        warnings.warn(\n            \"The 'forceLogin' keyword parameter is deprecated and will be removed in a future release. \"\n            \"Use force_login instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        force_login = kwargs[\"forceLogin\"]\n\n    if not self._is_connected() or force_login:\n        try:\n            self.__login()\n            self.__set_account()\n        except (KeycloakError, LoginError) as exc:\n            # Login failed\n            self._access_token = None\n            raise LoginError(\n                \"Login failed due to an authorization failure, please verify your email and password\"\n            ) from exc\n        except ServerError as exc:\n            raise ServerError(\"Login failed due to a request exception, please try again later\") from exc\n\n    return self.access_token</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.userinfo","title":"userinfo","text":"<pre><code>userinfo(token)</code></pre> <p>Retrieve user information using the provided access token.</p> <p>Parameters:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>The access token used for authentication.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>JSON response containing user information.</p> </li> </ul> Notes <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Raises:</p> <ul> <li> <code>RequestException</code>             \u2013            <p>If an error occurs while making the HTTP request.</p> </li> </ul> Example <p>client = PyEcotrendIsta(email='user@example.com', password='password') token = client.login() user_info = client.userinfo(token)</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def userinfo(self, token):\n    \"\"\"Retrieve user information using the provided access token.\n\n    Parameters\n    ----------\n    token : str\n        The access token used for authentication.\n\n    Returns\n    -------\n    Any\n        JSON response containing user information.\n\n    Notes\n    -----\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API.\n    It expects a JSON response with user information.\n\n    Raises\n    ------\n    requests.exceptions.RequestException\n        If an error occurs while making the HTTP request.\n\n    Example\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; token = client.login()\n    &gt;&gt;&gt; user_info = client.userinfo(token)\n\n    \"\"\"\n    return self.loginhelper.userinfo(token=token)</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.logout","title":"logout","text":"<pre><code>logout() -&gt; None</code></pre> <p>Perform logout operation by invalidating the current session.</p> <p>This method invokes the logout functionality in the loginhelper module, passing the current refresh token for session invalidation.</p> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If an error occurs during the logout process. This error is raised based on the response from the logout request.</p> </li> </ul> Example: <p>client = PyEcotrendIsta(email='user@example.com', password='password') client.login() client.logout()</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Perform logout operation by invalidating the current session.\n\n    This method invokes the logout functionality in the loginhelper module,\n    passing the current refresh token for session invalidation.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    Raises\n    ------\n    KeycloakPostError\n        If an error occurs during the logout process. This error is raised based on the response from the logout request.\n\n    Example:\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; client.logout()\n\n    \"\"\"\n    if self.loginhelper.username != DEMO_USER_ACCOUNT:\n        self.loginhelper.logout(self._refresh_token)</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_uuids","title":"get_uuids","text":"<pre><code>get_uuids() -&gt; list[str]</code></pre> <p>Retrieve UUIDs of consumption units registered in the account.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing UUIDs of consumption units. Each UUID represents a consumption unit, which could be a flat or a house for which consumption readings are provided.</p> </li> </ul> Notes <p>A consumption unit represents a residence or building where consumption readings are recorded. The UUIDs are extracted from the <code>_residentAndConsumptionUuidsMap</code> attribute.</p> Example: <p>client = PyEcotrendIsta(email='user@example.com', password='password') client.login() uuids = client.get_uuids() print(uuids) ['uuid1', 'uuid2', 'uuid3']</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_uuids(self) -&gt; list[str]:\n    \"\"\"Retrieve UUIDs of consumption units registered in the account.\n\n    Returns\n    -------\n    list[str]\n        A list containing UUIDs of consumption units. Each UUID represents a consumption unit,\n        which could be a flat or a house for which consumption readings are provided.\n\n    Notes\n    -----\n    A consumption unit represents a residence or building where consumption readings are recorded.\n    The UUIDs are extracted from the `_residentAndConsumptionUuidsMap` attribute.\n\n    Example:\n    -------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email='user@example.com', password='password')\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; uuids = client.get_uuids()\n    &gt;&gt;&gt; print(uuids)\n    ['uuid1', 'uuid2', 'uuid3']\n\n    \"\"\"\n    return list(self._account.get(\"residentAndConsumptionUuidsMap\", {}).values())</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw","title":"consum_raw","text":"<pre><code>consum_raw(select_year: list[int] | None = None, select_month: list[int] | None = None, filter_none: bool = True, obj_uuid: str | None = None) -&gt; dict[str, Any] | ConsumptionsResponse</code></pre> <p>Process consumption and cost data for a given consumption unit.</p> <p>Parameters:</p> <ul> <li> <code>select_year</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of years to filter data by year, default is None.</p> </li> <li> <code>select_month</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of months to filter data by month, default is None.</p> </li> <li> <code>filter_none</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to filter out None values in readings, default is True.</p> </li> <li> <code>obj_uuid</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>UUID of the consumption unit to fetch data for, default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | ConsumptionsResponse</code>           \u2013            <p>Processed data including consumption types, total additional values, last values, last costs, sum by year, and last year compared consumption.</p> </li> </ul> Notes <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an unexpected error during data processing.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def consum_raw(  # noqa: C901\n    self,\n    select_year: list[int] | None = None,\n    select_month: list[int] | None = None,\n    filter_none: bool = True,\n    obj_uuid: str | None = None,\n) -&gt; dict[str, Any] | ConsumptionsResponse:  # noqa: C901\n    \"\"\"Process consumption and cost data for a given consumption unit.\n\n    Parameters\n    ----------\n    select_year : list[int] | None, optional\n        List of years to filter data by year, default is None.\n    select_month : list[int] | None, optional\n        List of months to filter data by month, default is None.\n    filter_none : bool, optional\n        Whether to filter out None values in readings, default is True.\n    obj_uuid : str | None, optional\n        UUID of the consumption unit to fetch data for, default is None.\n\n    Returns\n    -------\n    dict[str, Any] | ConsumptionsResponse\n        Processed data including consumption types, total additional values, last values,\n        last costs, sum by year, and last year compared consumption.\n\n    Notes\n    -----\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Raises\n    ------\n    Exception\n        If there is an unexpected error during data processing.\n\n    \"\"\"\n    # Fetch raw consumption data for the specified UUID\n    c_raw: ConsumptionsResponse = self.get_consumption_data(obj_uuid)\n\n    if not isinstance(c_raw, dict) or (c_raw.get(\"consumptions\") is None and c_raw.get(\"costs\") is None):\n        return c_raw\n\n    if \"consumptions\" not in c_raw or not isinstance(c_raw.get(\"consumptions\"), list):\n        c_raw[\"consumptions\"] = []\n\n    consum_types = []\n    all_dates = []\n    indices_to_delete_consumption = []\n\n    for i, consumption in enumerate(c_raw.get(\"consumptions\", [])):\n        if (\n            not isinstance(consumption, dict)\n            or \"readings\" not in consumption\n            or consumption.get(\"readings\") is None\n            or not isinstance(consumption.get(\"readings\"), list)\n        ):\n            consumption = {}\n            continue\n\n        for reading in consumption.get(\"readings\", []):\n            if reading[\"additionalValue\"] is not None or reading[\"value\"] is not None:\n                consum_types.append(reading[\"type\"])\n\n        consum_types = list({consum_type for consum_type in consum_types if i is not None})\n\n        new_readings = []\n        if \"date\" in consumption:\n            all_dates.append(consumption[\"date\"])\n        if select_month is None and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif (\n            select_year is not None\n            and select_month is not None\n            and consumption[\"date\"][\"year\"] in select_year\n            and consumption[\"date\"][\"month\"] in select_month\n        ):\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_year is not None and consumption[\"date\"][\"year\"] in select_year and select_month is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_month is not None and consumption[\"date\"][\"month\"] in select_month and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        if new_readings:\n            consumption[\"readings\"] = new_readings\n        else:\n            indices_to_delete_consumption.append(i)\n\n    for index in sorted(indices_to_delete_consumption, reverse=True):\n        if index &lt; len(c_raw[\"consumptions\"]):\n            del c_raw[\"consumptions\"][index]\n\n    _all_date = all_dates\n    new_date = []\n    sum_by_year = {}\n    for date in _all_date:\n        if select_year is None or date[\"year\"] in select_year:\n            new_date.append(date[\"year\"])\n    new_date = list(dict.fromkeys(new_date))\n\n    cost_consum_types = consum_types\n\n    sum_by_year = {typ: {year: 0.0 for year in new_date} for typ in cost_consum_types}\n\n    for item in c_raw.get(\"consumptions\", []):\n        if \"readings\" not in item or not item[\"readings\"]:\n            continue\n        for reading in item.get(\"readings\", []):\n            if reading.get(\"type\", None) is None:\n                continue\n            for typ in cost_consum_types:\n                for year in new_date:\n                    if reading[\"type\"] == typ and item[\"date\"][\"year\"] == year:\n                        if reading[\"value\"]:\n                            sum_by_year[typ][year] += round(\n                                float(reading[\"value\"].replace(\",\", \".\")),\n                                1,\n                            )\n                        else:\n                            sum_by_year[typ][year] += round(\n                                (\n                                    float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                                    if reading[\"additionalValue\"] is not None\n                                    else 0.0\n                                ),\n                                1,\n                            )\n\n                        if reading[\"type\"] == \"warmwater\":\n                            sum_by_year[\"ww\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"water\":\n                            sum_by_year[\"w\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                            sum_by_year[\"h\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\":\n                            sum_by_year[\"h\"] = reading[\"additionalUnit\"]\n\n    indices_to_delete_costs = []\n\n    if \"costs\" not in c_raw or not isinstance(c_raw.get(\"costs\"), list):\n        c_raw[\"costs\"] = []\n\n    for i, costs in enumerate(c_raw.get(\"costs\", [])):\n        new_readings = []\n        if \"costsByEnergyType\" in costs:\n            if select_month is None and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif (\n                select_year is not None\n                and select_month is not None\n                and costs[\"date\"][\"year\"] in select_year\n                and costs[\"date\"][\"month\"] in select_month\n            ):\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_year is not None and costs[\"date\"][\"year\"] in select_year and select_month is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_month is not None and costs[\"date\"][\"month\"] in select_month and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n        if new_readings:\n            costs[\"costsByEnergyType\"] = new_readings\n        else:\n            indices_to_delete_costs.append(i)\n    for index in sorted(indices_to_delete_costs, reverse=True):\n        if \"costs\" in c_raw and index &lt; len(c_raw[\"costs\"]):\n            del c_raw[\"costs\"][index]\n\n    for key in [\n        \"consumptionsBillingPeriods\",\n        \"costsBillingPeriods\",\n        \"resident\",\n        \"co2Emissions\",\n        \"co2EmissionsBillingPeriods\",\n    ]:\n        if key in c_raw:\n            del c_raw[key]\n\n    consumptions: list = c_raw.get(\"consumptions\", [])\n    costs: list = c_raw.get(\"costs\", [])\n\n    combined_data = []\n    for cost_entry in costs:\n        for consumption_entry in consumptions:\n            # \u00dcberpr\u00fcfen, ob die Daten das gleiche Datum haben\n            if cost_entry[\"date\"] == consumption_entry[\"date\"]:\n                # Wenn ja, kombiniere die Kosten- und Verbrauchsdaten in einem Eintrag\n                combined_entry = {\n                    \"date\": cost_entry[\"date\"],\n                    \"consumptions\": consumption_entry[\"readings\"],\n                    \"costs\": cost_entry[\"costsByEnergyType\"],\n                }\n\n                combined_data.append(combined_entry)\n\n    total_additional_values = {}\n    total_additional_custom_values = {}\n    for consumption_unit in consumptions:\n        if \"readings\" not in consumption_unit or not consumption_unit[\"readings\"]:\n            continue\n        for reading in consumption_unit.get(\"readings\", []):\n            if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                continue\n\n            if reading[\"type\"] not in total_additional_custom_values:\n                total_additional_custom_values[reading[\"type\"]] = 0.0\n            if reading[\"additionalValue\"]:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    float(reading[\"additionalValue\"].replace(\",\", \".\")), 1\n                )\n            else:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    (float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_custom_values[\"ww\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_custom_values[\"w\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                total_additional_custom_values[\"h\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_custom_values[\"h\"] = reading[\"unit\"]\n\n            if reading[\"type\"] not in total_additional_values:\n                total_additional_values[reading[\"type\"]] = 0.0\n            if reading[\"value\"]:\n                total_additional_values[reading[\"type\"]] += round(float(reading[\"value\"].replace(\",\", \".\")), 1)\n            else:\n                total_additional_values[reading[\"type\"]] += round(\n                    (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    ),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_values[\"ww\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_values[\"w\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                total_additional_values[\"h\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_values[\"h\"] = reading[\"additionalUnit\"]\n\n    last_value = None\n    last_custom_value = None\n    last_year_compared_consumption = None\n\n    if consumptions:\n        last_value = {}\n        last_custom_value = {}\n        last_year_compared_consumption = {}\n\n        if len(consumptions) &gt; 0 and \"readings\" in consumptions[0] and consumptions[0][\"readings\"]:\n            for reading in consumptions[0][\"readings\"]:\n                if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                    continue\n\n                if reading[\"comparedConsumption\"]:\n                    last_year_compared_consumption[reading[\"type\"]] = reading[\"comparedConsumption\"]\n                    last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"] = float(\n                        last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"].replace(\",\", \".\")\n                    )\n\n                    if reading[\"value\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"value\"].replace(\",\", \".\")\n                        )\n                    elif reading[\"additionalValue\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"additionalValue\"].replace(\",\", \".\")\n                        )\n                    if \"period\" in last_year_compared_consumption[reading[\"type\"]]:\n                        del last_year_compared_consumption[reading[\"type\"]][\"period\"]\n\n                if reading[\"type\"] not in last_custom_value:\n                    last_custom_value[reading[\"type\"]] = 0.0\n                if reading[\"additionalValue\"]:\n                    last_custom_value[reading[\"type\"]] += float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                else:\n                    last_custom_value[reading[\"type\"]] += (\n                        float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0\n                    )\n\n                if reading[\"type\"] == \"warmwater\":\n                    last_custom_value[\"ww\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_custom_value[\"w\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_custom_value[\"h\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_custom_value[\"h\"] = reading[\"unit\"]\n\n                if reading[\"type\"] not in last_value:\n                    last_value[reading[\"type\"]] = 0.0\n                if reading[\"value\"]:  # reading[\"type\"] in (\"warmwater\", \"water\", \"heating\") and\n                    last_value[reading[\"type\"]] += float(reading[\"value\"].replace(\",\", \".\"))\n                else:\n                    last_value[reading[\"type\"]] += (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    )\n                if reading[\"type\"] == \"warmwater\":\n                    last_value[\"ww\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_value[\"w\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_value[\"h\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_value[\"h\"] = reading[\"additionalUnit\"]\n\n        last_custom_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_custom_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n        last_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n    last_costs = None\n    if costs:\n        if last_costs is None:\n            last_costs = {}\n        for costs_by_energy_type in costs[0][\"costsByEnergyType\"]:\n            if (\n                costs_by_energy_type is None\n                or \"type\" not in costs_by_energy_type\n                or costs_by_energy_type[\"type\"] is None\n                or \"comparedCost\" not in costs_by_energy_type\n                or costs_by_energy_type[\"comparedCost\"] is None\n                or \"smiley\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"smiley\"] is None\n                or \"comparedPercentage\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] is None\n            ):\n                continue\n\n            if costs_by_energy_type[\"type\"] not in last_costs:\n                last_costs[costs_by_energy_type[\"type\"]] = 0.0\n            last_costs[costs_by_energy_type[\"type\"]] += costs_by_energy_type[\"value\"]\n            last_costs[\"unit\"] = costs_by_energy_type[\"unit\"]\n            if costs_by_energy_type[\"type\"] == \"warmwater\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"water\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"heating\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n        last_costs[\"month\"] = costs[0][\"date\"][\"month\"]\n        last_costs[\"year\"] = costs[0][\"date\"][\"year\"]\n\n    return CustomRaw.from_dict(\n        {\n            \"consum_types\": consum_types,\n            \"combined_data\": None,  # combined_data,\n            \"total_additional_values\": total_additional_values,\n            \"total_additional_custom_values\": total_additional_custom_values,\n            \"last_value\": last_value,\n            \"last_custom_value\": last_custom_value,\n            \"last_costs\": last_costs,\n            \"all_dates\": None,  # all_dates,\n            \"sum_by_year\": sum_by_year,\n            \"last_year_compared_consumption\": last_year_compared_consumption,\n        }\n    ).to_dict()</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_consumption_data","title":"get_consumption_data","text":"<pre><code>get_consumption_data(obj_uuid: str | None = None) -&gt; ConsumptionsResponse</code></pre> <p>Fetch consumption data from the API for a specific consumption unit.</p> <p>Parameters:</p> <ul> <li> <code>obj_uuid</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The UUID of the consumption unit. If not provided, defaults to the UUID associated with the instance (<code>self._uuid</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A dictionary containing the consumption data fetched from the API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an error indicating authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the provided UUID is invalid.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_data(self, obj_uuid: str | None = None) -&gt; ConsumptionsResponse:\n    \"\"\"Fetch consumption data from the API for a specific consumption unit.\n\n    Parameters\n    ----------\n    obj_uuid : str, optional\n        The UUID of the consumption unit. If not provided,\n        defaults to the UUID associated with the instance (`self._uuid`).\n\n    Returns\n    -------\n    ConsumptionsResponse\n        A dictionary containing the consumption data fetched from the API.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an error indicating authorization failure.\n    ParserError\n        If there is an error parsing the request response.\n    ValueError\n        If the provided UUID is invalid.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n\n    params = {\n        \"consumptionUnitUuid\": obj_uuid or self._uuid\n    }\n    url = f\"{API_BASE_URL}consumptions\"\n    try:\n        with self.session.get(url, params=params, headers=self._header, ) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text[:100])\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption data failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption data failed failed due to an authorization failure\") from exc\n        if exc.response.status_code == HTTPStatus.BAD_REQUEST:\n            raise ValueError(\n                f\"Invalid UUID. Retrieving data for consumption unit {obj_uuid or self._uuid} failed\"\n            ) from exc\n        raise ServerError(\n            \"Loading consumption data failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption data failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption data failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_consumption_unit_details","title":"get_consumption_unit_details","text":"<pre><code>get_consumption_unit_details() -&gt; ConsumptionUnitDetailsResponse</code></pre> <p>Retrieve details of the consumption unit from the API.</p> <p>Returns:</p> <ul> <li> <code>ConsumptionUnitDetailsResponse</code>           \u2013            <p>A dictionary containing the details of the consumption unit.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an issue with decoding the JSON response</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_unit_details(self) -&gt; ConsumptionUnitDetailsResponse:\n    \"\"\"Retrieve details of the consumption unit from the API.\n\n    Returns\n    -------\n    ConsumptionUnitDetailsResponse\n        A dictionary containing the details of the consumption unit.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an authorization failure.\n    ParserError\n        If there is an issue with decoding the JSON response\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n    url = f\"{API_BASE_URL}menu\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionUnitDetailsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption unit details failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption unit details failed failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading consumption unit details failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption unit details failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption unit details failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_support_code","title":"get_support_code","text":"<pre><code>get_support_code() -&gt; str | None</code></pre> <p>Return the support code associated with the instance.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The support code associated with the instance, or None if not set.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_support_code(self) -&gt; str | None:\n    \"\"\"Return the support code associated with the instance.\n\n    Returns\n    -------\n    str or None\n        The support code associated with the instance, or None if not set.\n\n    \"\"\"\n    return getattr(self, \"_account\", {}).get(\"supportCode\")</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_user_agent","title":"get_user_agent","text":"<pre><code>get_user_agent() -&gt; str</code></pre> <p>Return the User-Agent string used for HTTP requests.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The User-Agent string.</p> </li> </ul> Notes <p>This method provides a static User-Agent string commonly used for web browsers.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_user_agent(self) -&gt; str:\n    \"\"\"Return the User-Agent string used for HTTP requests.\n\n    Returns\n    -------\n    str\n        The User-Agent string.\n\n    Notes\n    -----\n    This method provides a static User-Agent string commonly used for web browsers.\n\n    \"\"\"\n    return (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67\"\n        \" Safari/537.36\"\n    )</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.demo_user_login","title":"demo_user_login","text":"<pre><code>demo_user_login() -&gt; GetTokenResponse</code></pre> <p>Retrieve authentication tokens for the demo user.</p> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def demo_user_login(self) -&gt; GetTokenResponse:\n    \"\"\"Retrieve authentication tokens for the demo user.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    \"\"\"\n    url = f\"{API_BASE_URL}demo-user-token\"\n    try:\n        self._header[\"User-Agent\"] = self.get_user_agent()\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                data = r.json()\n                key = iter(GetTokenResponse.__annotations__)\n                token = {next(key): value for value in data.values()}\n                return cast(GetTokenResponse, token)\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Demo user authentication failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        raise ServerError(\n            \"Demo user authentication failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Demo user authentication failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Demo user authentication failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_account","title":"get_account","text":"<pre><code>get_account() -&gt; AccountResponse | None</code></pre> <p>Retrieve the account information.</p> <p>Returns the <code>_account</code> attribute if it exists, otherwise returns None.</p> <p>Returns:</p> <ul> <li> <code>AccountResponse | None</code>           \u2013            <p>Account information if available, otherwise None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_account(self) -&gt; AccountResponse | None:\n    \"\"\"Retrieve the account information.\n\n    Returns the `_account` attribute if it exists, otherwise returns None.\n\n    Returns\n    -------\n    AccountResponse | None\n        Account information if available, otherwise None.\n\n    \"\"\"\n    return getattr(self, \"_account\", None)</code></pre>"},{"location":"types/","title":"Types","text":""},{"location":"types/#pyecotrend_ista.types","title":"pyecotrend_ista.types","text":"<p>Types for PyEcotrendIsta.</p>"},{"location":"types/#pyecotrend_ista.types.GetTokenResponse","title":"GetTokenResponse","text":"<p>A TypedDict for the response returned by the getToken function.</p> <p>Attributes:</p> <ul> <li> <code>access_token</code>               (<code>str</code>)           \u2013            <p>The access token issued by the authentication provider.</p> </li> <li> <code>expires_in</code>               (<code>int</code>)           \u2013            <p>The number of seconds until the access token expires.</p> </li> <li> <code>refresh_token</code>               (<code>str</code>)           \u2013            <p>The refresh token that can be used to obtain new access tokens.</p> </li> <li> <code>refresh_expires_in</code>               (<code>int</code>)           \u2013            <p>The number of seconds until the refresh token expires.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.AccountResponse","title":"AccountResponse","text":"<p>Represents the response for an account in the ista EcoTrend API.</p> <p>Attributes:</p> <ul> <li> <code>firstName</code>               (<code>str</code>)           \u2013            <p>The first name of the account holder.</p> </li> <li> <code>lastName</code>               (<code>str</code>)           \u2013            <p>The last name of the account holder.</p> </li> <li> <code>email</code>               (<code>str</code>)           \u2013            <p>The email address of the account holder.</p> </li> <li> <code>keycloakId</code>               (<code>str</code>)           \u2013            <p>The Keycloak ID associated with the account.</p> </li> <li> <code>country</code>               (<code>str</code>)           \u2013            <p>The country associated with the account.</p> </li> <li> <code>locale</code>               (<code>str</code>)           \u2013            <p>The locale setting for the account.</p> </li> <li> <code>authcode</code>               (<code>str</code>)           \u2013            <p>The authentication code for the account.</p> </li> <li> <code>tos</code>               (<code>str</code>)           \u2013            <p>The terms of service agreed to by the account holder.</p> </li> <li> <code>tosUpdated</code>               (<code>str</code>)           \u2013            <p>The date the terms of service were last updated.</p> </li> <li> <code>privacy</code>               (<code>str</code>)           \u2013            <p>The privacy setting for the account.</p> </li> <li> <code>mobileNumber</code>               (<code>str</code>)           \u2013            <p>The mobile phone number associated with the account.</p> </li> <li> <code>transitionMobileNumber</code>               (<code>str</code>)           \u2013            <p>The mobile number used during the transition period.</p> </li> <li> <code>unconfirmedPhoneNumber</code>               (<code>str</code>)           \u2013            <p>The unconfirmed phone number associated with the account.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>The password for the account.</p> </li> <li> <code>enabled</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account is enabled.</p> </li> <li> <code>consumptionUnitUuids</code>               (<code>list of str</code>)           \u2013            <p>List of UUIDs for the consumption units.</p> </li> <li> <code>residentTimeRangeUuids</code>               (<code>list of str</code>)           \u2013            <p>List of UUIDs for the resident time ranges.</p> </li> <li> <code>ads</code>               (<code>bool</code>)           \u2013            <p>Indicates whether advertisements are enabled.</p> </li> <li> <code>marketing</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account holder has opted into marketing communications.</p> </li> <li> <code>fcmToken</code>               (<code>str</code>)           \u2013            <p>The FCM (Firebase Cloud Messaging) token for push notifications.</p> </li> <li> <code>betaPhase</code>               (<code>str</code>)           \u2013            <p>Indicates if the account is in the beta phase.</p> </li> <li> <code>notificationMethod</code>               (<code>str</code>)           \u2013            <p>The method of notification preferred by the account holder.</p> </li> <li> <code>emailConfirmed</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the email address is confirmed.</p> </li> <li> <code>isDemo</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account is a demo account.</p> </li> <li> <code>userGroup</code>               (<code>str</code>)           \u2013            <p>The user group the account belongs to.</p> </li> <li> <code>mobileLoginStatus</code>               (<code>str</code>)           \u2013            <p>The status of mobile login for the account.</p> </li> <li> <code>residentAndConsumptionUuidsMap</code>               (<code>dict of str to str</code>)           \u2013            <p>A map of resident UUIDs to consumption unit UUIDs.</p> </li> <li> <code>activeConsumptionUnit</code>               (<code>str</code>)           \u2013            <p>The UUID of the active consumption unit.</p> </li> <li> <code>supportCode</code>               (<code>str</code>)           \u2013            <p>The support code for the account.</p> </li> <li> <code>notificationMethodEmailConfirmed</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the email for notification method is confirmed.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaMonthYear","title":"IstaMonthYear","text":"<p>A TypedDict representing a month and year.</p> <p>Attributes:</p> <ul> <li> <code>month</code>               (<code>int</code>)           \u2013            <p>The month value.</p> </li> <li> <code>year</code>               (<code>int</code>)           \u2013            <p>The year value.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaAverageConsumption","title":"IstaAverageConsumption","text":"<p>A TypedDict representing average consumption values.</p> <p>Attributes:</p> <ul> <li> <code>additionalAverageConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of additional average consumption.</p> </li> <li> <code>additionalAverageConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of additional average consumption.</p> </li> <li> <code>additionalResidentConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of additional resident consumption.</p> </li> <li> <code>additionalResidentConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of additional resident consumption.</p> </li> <li> <code>averageConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of average consumption.</p> </li> <li> <code>averageConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of average consumption.</p> </li> <li> <code>residentConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of resident consumption.</p> </li> <li> <code>residentConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of resident consumption.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaCompared","title":"IstaCompared","text":"<p>A TypedDict representing compared values.</p> <p>Attributes:</p> <ul> <li> <code>comparedPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage comparison value.</p> </li> <li> <code>comparedValue</code>               (<code>str</code>)           \u2013            <p>Compared value.</p> </li> <li> <code>lastYearValue</code>               (<code>float</code>)           \u2013            <p>Value from the last year.</p> </li> <li> <code>period</code>               (<code>IstaMonthYear</code>)           \u2013            <p>Period associated with the comparison.</p> </li> <li> <code>smiley</code>               (<code>str</code>)           \u2013            <p>Smiley associated with the comparison.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaReading","title":"IstaReading","text":"<p>A TypedDict representing a reading.</p> <p>Attributes:</p> <ul> <li> <code>additionalUnit</code>               (<code>str</code>)           \u2013            <p>Additional unit associated with the reading.</p> </li> <li> <code>additionalValue</code>               (<code>str</code>)           \u2013            <p>Additional value associated with the reading.</p> </li> <li> <code>averageConsumption</code>               (<code>IstaAverageConsumption</code>)           \u2013            <p>Average consumption details.</p> </li> <li> <code>comparedConsumption</code>               (<code>dict</code>)           \u2013            <p>Compared consumption details.</p> </li> <li> <code>comparedCost</code>               (<code>IstaCompared</code>)           \u2013            <p>Compared cost details.</p> </li> <li> <code>estimated</code>               (<code>bool</code>)           \u2013            <p>Indicates if the reading is estimated.</p> </li> <li> <code>type</code>               (<code>Literal['heating', 'warmwater', 'water']</code>)           \u2013            <p>Type of the reading (heating, warmwater, water).</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>Unit of measurement for the reading.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>Value of the reading.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaTimeRange","title":"IstaTimeRange","text":"<p>A TypedDict representing a time range.</p> <p>Attributes:</p> <ul> <li> <code>end</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The end of the time range.</p> </li> <li> <code>start</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The start of the time range.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaBillingPeriod","title":"IstaBillingPeriod","text":"<p>A TypedDict representing a billing period.</p> <p>Attributes:</p> <ul> <li> <code>exception</code>               (<code>(Any, optional)</code>)           \u2013            <p>Any exceptions related to this billing period. (data type unknown)</p> </li> <li> <code>readings</code>               (<code>list[IstaReading]</code>)           \u2013            <p>List of readings associated with this billing period.</p> </li> <li> <code>timeRange</code>               (<code>IstaTimeRange</code>)           \u2013            <p>The time range for this billing period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaBillingPeriods","title":"IstaBillingPeriods","text":"<p>A TypedDict representing the billing periods.</p> <p>Attributes:</p> <ul> <li> <code>currentBillingPeriod</code>               (<code>IstaBillingPeriod</code>)           \u2013            <p>The details of the current billing period.</p> </li> <li> <code>previousBillingPeriod</code>               (<code>IstaBillingPeriod</code>)           \u2013            <p>The details of the previous billing period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaCostsByEnergyType","title":"IstaCostsByEnergyType","text":"<p>A TypedDict representing the costs associated with a specific energy type.</p> <p>Attributes:</p> <ul> <li> <code>comparedCost</code>               (<code>IstaCompared</code>)           \u2013            <p>The cost comparison data for the energy type.</p> </li> <li> <code>estimated</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the cost is estimated.</p> </li> <li> <code>type</code>               (<code>Literal['heating', 'warmwater', 'water']</code>)           \u2013            <p>The type of energy (heating, warm water, or water).</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>The unit of measurement for the cost.</p> </li> <li> <code>value</code>               (<code>int</code>)           \u2013            <p>The cost value.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaPeriods","title":"IstaPeriods","text":"<p>A TypedDict representing data for a specific period.</p> <p>Attributes:</p> <ul> <li> <code>date</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The month and year for the period.</p> </li> <li> <code>documentNumber</code>               (<code>str | None</code>)           \u2013            <p>The document number associated with the period, if any.</p> </li> <li> <code>exception</code>               (<code>Any</code>)           \u2013            <p>An exception associated with the period (data type unspecified).</p> </li> <li> <code>isSCEedBasic</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the period.</p> </li> <li> <code>readings</code>               (<code>list[IstaReading]</code>)           \u2013            <p>A list of readings recorded during the period.</p> </li> <li> <code>costsByEnergyType</code>               (<code>list[IstaCostsByEnergyType]</code>)           \u2013            <p>A list of costs categorized by energy type for the period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.ConsumptionsResponse","title":"ConsumptionsResponse","text":"<p>A TypedDict representing the response structure for consumption data.</p> <p>Attributes:</p> <ul> <li> <code>co2Emissions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different periods.</p> </li> <li> <code>co2EmissionsBillingPeriods</code>               (<code>list[IstaBillingPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different billing periods.</p> </li> <li> <code>consumptionUnitId</code>               (<code>str</code>)           \u2013            <p>The unique identifier for the consumption unit.</p> </li> <li> <code>consumptions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of consumption data over different periods.</p> </li> <li> <code>consumptionsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The consumption data over different billing periods.</p> </li> <li> <code>costs</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of cost data over different periods.</p> </li> <li> <code>costsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The cost data over different billing periods.</p> </li> <li> <code>isSCEedBasicForCurrentMonth</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the current month.</p> </li> <li> <code>nonEEDBasicStartDate</code>               (<code>Any</code>)           \u2013            <p>The start date for non-EED basic plan (data type unknown).</p> </li> <li> <code>resident</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary containing resident information.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnitAddress","title":"IstaConsumptionUnitAddress","text":"<p>Represents the address of a consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>street</code>               (<code>str</code>)           \u2013            <p>The street name of the address.</p> </li> <li> <code>houseNumber</code>               (<code>str</code>)           \u2013            <p>The house number of the address.</p> </li> <li> <code>postalCode</code>               (<code>str</code>)           \u2013            <p>The postal code of the address.</p> </li> <li> <code>city</code>               (<code>str</code>)           \u2013            <p>The city of the address.</p> </li> <li> <code>country</code>               (<code>str</code>)           \u2013            <p>The country code of the address.</p> </li> <li> <code>floor</code>               (<code>str</code>)           \u2013            <p>The floor number of the address.</p> </li> <li> <code>propertyNumber</code>               (<code>str</code>)           \u2013            <p>The property number of the address.</p> </li> <li> <code>consumptionUnitNumber</code>               (<code>str</code>)           \u2013            <p>The consumption unit number associated with the address.</p> </li> <li> <code>idAtCustomerUser</code>               (<code>str</code>)           \u2013            <p>The ID assigned to the address at the customer user's end.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnitBookedServices","title":"IstaConsumptionUnitBookedServices","text":"<p>Represents the booked extra services for an Ista consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>cost</code>               (<code>bool</code>)           \u2013            <p>Indicates if cost service is booked.</p> </li> <li> <code>co2</code>               (<code>bool</code>)           \u2013            <p>Indicates if CO2 service is booked.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnit","title":"IstaConsumptionUnit","text":"<p>Represents a consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The UUID of the consumption unit.</p> </li> <li> <code>address</code>               (<code>IstaConsumptionUnitAddress</code>)           \u2013            <p>The address details of the consumption unit.</p> </li> <li> <code>booked</code>               (<code>IstaConsumptionUnitBookedServices</code>)           \u2013            <p>The booked services for the consumption unit.</p> </li> <li> <code>propertyNumber</code>               (<code>str</code>)           \u2013            <p>The property number associated with the consumption unit.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.ConsumptionUnitDetailsResponse","title":"ConsumptionUnitDetailsResponse","text":"<p>Represents the response details for consumption units.</p> <p>Attributes:</p> <ul> <li> <code>consumptionUnits</code>               (<code>list[IstaConsumptionUnit]</code>)           \u2013            <p>The list of consumption units.</p> </li> <li> <code>coBranding</code>               (<code>Any</code>)           \u2013            <p>Co-branding information (data type unknown).</p> </li> </ul>"}]}