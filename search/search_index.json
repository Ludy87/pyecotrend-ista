{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyEcoTrend-ista","text":"<p>\u2728 Wishlist from Amazon \u2728</p> <p>Unofficial python library for the pyecotrend-ista API</p> <p></p>"},{"location":"#pyecotrend_ista","title":"pyecotrend_ista","text":"<p>PyEcotrend Ista.</p> <p>Modules:</p> <ul> <li> <code>const</code>           \u2013            <p>Constants for PyEcotrendIsta.</p> </li> <li> <code>exception_classes</code>           \u2013            <p>Exception Class.</p> </li> <li> <code>helper_object_de</code>           \u2013            <p>Dataclasses.</p> </li> <li> <code>login_helper</code>           \u2013            <p>Login helper for Keycloak.</p> </li> <li> <code>pyecotrend_ista</code>           \u2013            <p>Unofficial python library for the ista EcoTrend API.</p> </li> <li> <code>types</code>           \u2013            <p>Types for PyEcotrendIsta.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>KeycloakAuthenticationError</code>           \u2013            <p>Keycloak authentication error exception.</p> </li> <li> <code>KeycloakError</code>           \u2013            <p>Base class for custom Keycloak errors.</p> </li> <li> <code>KeycloakGetError</code>           \u2013            <p>Keycloak request get error exception.</p> </li> <li> <code>KeycloakInvalidTokenError</code>           \u2013            <p>Keycloak invalid token exception.</p> </li> <li> <code>KeycloakOperationError</code>           \u2013            <p>Keycloak operation error exception.</p> </li> <li> <code>KeycloakPostError</code>           \u2013            <p>Keycloak request post error exception.</p> </li> <li> <code>LoginError</code>           \u2013            <p>Exception raised for login- and authentication related errors.</p> </li> <li> <code>ParserError</code>           \u2013            <p>Exception raised for errors encountered during parsing.</p> </li> <li> <code>ServerError</code>           \u2013            <p>Exception raised for server errors during requests.</p> </li> <li> <code>PyEcotrendIsta</code>           \u2013            <p>A Python client for interacting with the ista EcoTrend API.</p> </li> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A TypedDict representing the response structure for consumption data.</p> </li> </ul>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError","title":"KeycloakAuthenticationError","text":"<pre><code>KeycloakAuthenticationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak authentication error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakAuthenticationError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakError","title":"KeycloakError","text":"<pre><code>KeycloakError(error_message='', response_code=None, response_body=None)</code></pre> <p>Base class for custom Keycloak errors.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakGetError","title":"KeycloakGetError","text":"<pre><code>KeycloakGetError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request get error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakGetError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakGetError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakGetError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakGetError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError","title":"KeycloakInvalidTokenError","text":"<pre><code>KeycloakInvalidTokenError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak invalid token exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakInvalidTokenError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakOperationError","title":"KeycloakOperationError","text":"<pre><code>KeycloakOperationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak operation error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakOperationError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakOperationError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakOperationError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakOperationError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.KeycloakPostError","title":"KeycloakPostError","text":"<pre><code>KeycloakPostError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request post error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"#pyecotrend_ista.KeycloakPostError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"#pyecotrend_ista.KeycloakPostError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakPostError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"#pyecotrend_ista.KeycloakPostError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"#pyecotrend_ista.LoginError","title":"LoginError","text":"<p>Exception raised for login- and authentication related errors.</p> <p>This exception is raised when an authentication exception occurs during a request. It inherits from BaseError and is used specifically to handle issues related to authentication and login.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of an authentication error.</p> </li> </ul>"},{"location":"#pyecotrend_ista.LoginError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of an authentication error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of an authentication error.\"\"\"\n    return \"An authentication error occurred during the request\"</code></pre>"},{"location":"#pyecotrend_ista.ParserError","title":"ParserError","text":"<p>Exception raised for errors encountered during parsing.</p> <p>This exception is raised when an error occurs during the parsing process of the request response. It inherits from BaseError and can be used to handle issues specifically related to parsing.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of parser error.</p> </li> </ul>"},{"location":"#pyecotrend_ista.ParserError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of parser error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of parser error.\"\"\"\n    return \"Error occurred during parsing of the request response\"</code></pre>"},{"location":"#pyecotrend_ista.ServerError","title":"ServerError","text":"<p>Exception raised for server errors during requests.</p> <p>This exception is raised when a exception occurs during a request. It inherits from BaseError  and can be used to handle server-related issues specifically.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of the error..</p> </li> </ul>"},{"location":"#pyecotrend_ista.ServerError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of the error..</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the error..\"\"\"\n    return \"Server error occurred during the request\"</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta","title":"PyEcotrendIsta","text":"<pre><code>PyEcotrendIsta(email: str, password: str, logger: Logger | None = None, hass_dir: str | None = None, totp: str | None = None, session: Session | None = None)</code></pre> <p>A Python client for interacting with the ista EcoTrend API.</p> <p>This class provides methods to authenticate and interact with the ista EcoTrend API.</p> <p>Attributes:</p> <ul> <li> <code>_account</code>               (<code>AccountResponse</code>)           \u2013            <p>The account information.</p> </li> <li> <code>_uuid</code>               (<code>str</code>)           \u2013            <p>The UUID of the consumption unit.</p> </li> <li> <code>_access_token</code>               (<code>str | None</code>)           \u2013            <p>The access token for API authentication.</p> </li> <li> <code>_refresh_token</code>               (<code>str | None</code>)           \u2013            <p>The refresh token for obtaining new access tokens.</p> </li> <li> <code>_access_token_expires_in</code>               (<code>int</code>)           \u2013            <p>The expiration time of the access token.</p> </li> <li> <code>_header</code>               (<code>dict[str, str]</code>)           \u2013            <p>The headers used in HTTP requests.</p> </li> <li> <code>_support_code</code>               (<code>str | None</code>)           \u2013            <p>The support code for the account.</p> </li> <li> <code>_start_timer</code>               (<code>float</code>)           \u2013            <p>The start time for tracking elapsed time.</p> </li> </ul> <p>Examples:</p> <p>Initialize the client and log in:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()</code></pre> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_version</code>             \u2013              <p>Get the version of the PyEcotrendIsta client.</p> </li> <li> <code>login</code>             \u2013              <p>Perform the login process if not already connected or forced.</p> </li> <li> <code>userinfo</code>             \u2013              <p>Retrieve user information using the provided access token.</p> </li> <li> <code>logout</code>             \u2013              <p>Perform logout operation by invalidating the current session.</p> </li> <li> <code>get_uuids</code>             \u2013              <p>Retrieve UUIDs of consumption units registered in the account.</p> </li> <li> <code>consum_raw</code>             \u2013              <p>Process and filter consumption and cost data for a given consumption unit.</p> </li> <li> <code>get_consumption_data</code>             \u2013              <p>Fetch consumption data from the API for a specific consumption unit.</p> </li> <li> <code>get_consumption_unit_details</code>             \u2013              <p>Retrieve details of the consumption unit from the API.</p> </li> <li> <code>get_support_code</code>             \u2013              <p>Return the support code associated with the instance.</p> </li> <li> <code>get_user_agent</code>             \u2013              <p>Return the User-Agent string used for HTTP requests.</p> </li> <li> <code>demo_user_login</code>             \u2013              <p>Retrieve authentication tokens for the demo user.</p> </li> <li> <code>get_account</code>             \u2013              <p>Retrieve the account information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>access_token</code>           \u2013            <p>Retrieve the access token, refreshing it if necessary.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __init__(\n    self,\n    email: str,\n    password: str,\n    logger: logging.Logger | None = None,\n    hass_dir: str | None = None,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"Initialize the PyEcotrendIsta client.\n\n    Parameters\n    ----------\n    email : str\n        The email address used to log in to the ista EcoTrend API.\n    password : str\n        The password used to log in to the ista EcoTrend API.\n    logger : logging.Logger, optional\n        [DEPRECATED] An optional logger instance for logging messages. Default is None.\n    hass_dir : str, optional\n        [DEPRECATED] An optional directory for Home Assistant configuration. Default is None.\n    totp : str, optional\n        An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.\n    session : requests.Session, optional\n        An optional requests session for making HTTP requests. Default is None.\n    \"\"\"\n    if hass_dir:\n        warnings.warn(\n            \"The 'hass_dir' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if logger:\n        warnings.warn(\n            \"The 'logger' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    self._email: str = email.strip()\n    self._password: str = password\n\n    self.loginhelper = LoginHelper(\n        username=self._email,\n        password=self._password,\n        totp=totp,\n        session=session,\n        logger=_LOGGER,\n    )\n\n    self.session: requests.Session = self.loginhelper.session</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(email)","title":"<code>email</code>","text":"(<code>str</code>)           \u2013            <p>The email address used to log in to the ista EcoTrend API.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(password)","title":"<code>password</code>","text":"(<code>str</code>)           \u2013            <p>The password used to log in to the ista EcoTrend API.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional logger instance for logging messages. Default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(hass_dir)","title":"<code>hass_dir</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional directory for Home Assistant configuration. Default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(totp)","title":"<code>totp</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta(session)","title":"<code>session</code>","text":"(<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>An optional requests session for making HTTP requests. Default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.access_token","title":"access_token  <code>property</code> <code>writable</code>","text":"<pre><code>access_token</code></pre> <p>Retrieve the access token, refreshing it if necessary.</p> <p>This property checks if the access token is still valid. If the token has expired and the client is connected, it refreshes the token. The token is considered expired if the current time minus the start time exceeds the token's expiration period.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The current access token.</p> </li> </ul> Notes <p>This method will automatically refresh the access token if it has expired.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__login","title":"__login","text":"<pre><code>__login() -&gt; str | None</code></pre> <p>Perform the login process to obtain an access token.</p> <p>If the email is a demo account, it logs in using a demo user login function. For other accounts, it retrieves a token using a login helper.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __login(self) -&gt; str | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Perform the login process to obtain an access token.\n\n    If the email is a demo account, it logs in using a demo user login function.\n    For other accounts, it retrieves a token using a login helper.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n    \"\"\"\n    if self._email == DEMO_USER_ACCOUNT:\n        _LOGGER.debug(\"Logging in as demo user\")\n        token = self.demo_user_login()\n    else:\n        token = self.loginhelper.get_token()\n    if token:\n        self.access_token = token[\"access_token\"]\n        self._access_token_expires_in = token[\"expires_in\"]\n        self._refresh_token = token[\"refresh_token\"]\n        return self.access_token\n    return None</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__refresh","title":"__refresh","text":"<pre><code>__refresh() -&gt; None</code></pre> <p>Refresh the access token using the refresh token.</p> <p>This method retrieves a new access token, updates internal variables, and resets the token expiration timer.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If there is an authorization failure.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __refresh(self) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Refresh the access token using the refresh token.\n\n    This method retrieves a new access token, updates internal variables,\n    and resets the token expiration timer.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    LoginError\n        If there is an authorization failure.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n    \"\"\"\n    (\n        self.access_token,\n        self._access_token_expires_in,\n        self._refresh_token,\n    ) = self.loginhelper.refresh_token(self._refresh_token)\n\n    self._header[\"Authorization\"] = f\"Bearer {self.access_token}\"</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.__set_account","title":"__set_account","text":"<pre><code>__set_account() -&gt; None</code></pre> <p>Fetch and set account information from the API.</p> <p>This method performs an API request to retrieve account information, handles various potential errors that might occur during the request, and sets instance variables accordingly using the response data.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the JSON response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If the request fails due to an authorization error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If the request fails due to a server error, timeout, or other request exceptions.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __set_account(self) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Fetch and set account information from the API.\n\n    This method performs an API request to retrieve account information,\n    handles various potential errors that might occur during the request,\n    and sets instance variables accordingly using the response data.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the JSON response.\n    LoginError\n        If the request fails due to an authorization error.\n    ServerError\n        If the request fails due to a server error, timeout, or other request exceptions.\n    \"\"\"\n    self._header = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": self.get_user_agent(),\n        \"Authorization\": f\"Bearer {self.access_token}\",\n    }\n    url = f\"{API_BASE_URL}account\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n            r.raise_for_status()\n            try:\n                data = r.json()\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading account information failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading account information failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading account information failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading account information failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading account information failed due to a request exception\") from exc\n\n    self._account = cast(AccountResponse, data)\n    self._uuid = data[\"activeConsumptionUnit\"]</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str</code></pre> <p>Get the version of the PyEcotrendIsta client.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The version number of the PyEcotrendIsta client.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_version(self) -&gt; str:  # numpydoc ignore=EX01,ES01\n    \"\"\"\n    Get the version of the PyEcotrendIsta client.\n\n    Returns\n    -------\n    str\n        The version number of the PyEcotrendIsta client.\n    \"\"\"\n    return VERSION</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.login","title":"login","text":"<pre><code>login(force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None</code></pre> <p>Perform the login process if not already connected or forced.</p> <p>Parameters:</p> Deprecated Parameters <p>forceLogin : bool, optional     Use <code>force_login</code> instead. This parameter is deprecated and will be removed in a future release.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the login process fails due to an error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If a server error occurs during login attempts.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal server error occurs during login attempts.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any other unexpected errors during the login process.</p> </li> </ul> Notes <ul> <li>The <code>forceLogin</code> parameter is handled via <code>**kwargs</code> for backward compatibility.</li> <li>The <code>debug</code> parameter is deprecated; use appropriate logging configuration instead.</li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def login(self, force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None:  # numpydoc ignore=ES01,EX01,PR01,PR02\n    \"\"\"\n    Perform the login process if not already connected or forced.\n\n    Parameters\n    ----------\n    force_login : bool, optional\n        If True, forces a fresh login attempt even if already connected. Default is False.\n    debug : bool, optional\n        [DEPRECATED] Flag indicating whether to enable debug logging. Default is False.\n\n    Deprecated Parameters\n    ----------------------\n    forceLogin : bool, optional\n        Use `force_login` instead. This parameter is deprecated and will be removed in a future release.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    Raises\n    ------\n    LoginError\n        If the login process fails due to an error.\n    ServerError\n        If a server error occurs during login attempts.\n    InternalServerError\n        If an internal server error occurs during login attempts.\n    Exception\n        For any other unexpected errors during the login process.\n\n    Notes\n    -----\n    - The `forceLogin` parameter is handled via `**kwargs` for backward compatibility.\n    - The `debug` parameter is deprecated; use appropriate logging configuration instead.\n    \"\"\"\n    if debug:\n        warnings.warn(\n            \"The 'debug' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if \"forceLogin\" in kwargs:\n        warnings.warn(\n            \"The 'forceLogin' keyword parameter is deprecated and will be removed in a future release. \"\n            \"Use force_login instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        force_login = kwargs[\"forceLogin\"]\n\n    if not self._is_connected() or force_login:\n        try:\n            self.__login()\n            self.__set_account()\n        except (KeycloakError, LoginError) as exc:\n            # Login failed\n            self._access_token = None\n            raise LoginError(\n                \"Login failed due to an authorization failure, please verify your email and password\"\n            ) from exc\n        except ServerError as exc:\n            raise ServerError(\"Login failed due to a request exception, please try again later\") from exc\n\n    return self.access_token</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.login(force_login)","title":"<code>force_login</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, forces a fresh login attempt even if already connected. Default is False.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.login(debug)","title":"<code>debug</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[DEPRECATED] Flag indicating whether to enable debug logging. Default is False.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.userinfo","title":"userinfo","text":"<pre><code>userinfo(token)</code></pre> <p>Retrieve user information using the provided access token.</p> <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>JSON response containing user information.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>             \u2013            <p>If an error occurs while making the HTTP request.</p> </li> </ul> Notes <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; token = client.login()\n&gt;&gt;&gt; user_info = client.userinfo(token)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def userinfo(self, token):\n    \"\"\"\n    Retrieve user information using the provided access token.\n\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API. It expects\n    a JSON response with user information.\n\n    Parameters\n    ----------\n    token : str\n        The access token used for authentication.\n\n    Returns\n    -------\n    Any\n        JSON response containing user information.\n\n    Raises\n    ------\n    requests.exceptions.RequestException\n        If an error occurs while making the HTTP request.\n\n    Notes\n    -----\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API.\n    It expects a JSON response with user information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; token = client.login()\n    &gt;&gt;&gt; user_info = client.userinfo(token)\n    \"\"\"\n    return self.loginhelper.userinfo(token=token)</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.userinfo(token)","title":"<code>token</code>","text":"(<code>str</code>)           \u2013            <p>The access token used for authentication.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.logout","title":"logout","text":"<pre><code>logout() -&gt; None</code></pre> <p>Perform logout operation by invalidating the current session.</p> <p>This method invokes the logout functionality in the loginhelper module, passing the current refresh token for session invalidation.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            </li> <li> <code>If an error occurs during the logout process. This error is raised based on the response from the logout request.</code>             \u2013            </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()\n&gt;&gt;&gt; client.logout()</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"\n    Perform logout operation by invalidating the current session.\n\n    This method invokes the logout functionality in the loginhelper module,\n    passing the current refresh token for session invalidation.\n\n    Raises\n    ------\n    KeycloakPostError\n    If an error occurs during the logout process. This error is raised based on the response from the logout request.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; client.logout()\n    \"\"\"\n    if self.loginhelper.username != DEMO_USER_ACCOUNT:\n        self.loginhelper.logout(self._refresh_token)</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_uuids","title":"get_uuids","text":"<pre><code>get_uuids() -&gt; list[str]</code></pre> <p>Retrieve UUIDs of consumption units registered in the account.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing UUIDs of consumption units. Each UUID represents a consumption unit, which could be a flat or a house for which consumption readings are provided.</p> </li> </ul> Notes <p>A consumption unit represents a residence or building where consumption readings are recorded. The UUIDs are extracted from the <code>_residentAndConsumptionUuidsMap</code> attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()\n&gt;&gt;&gt; uuids = client.get_uuids()\n&gt;&gt;&gt; print(uuids)\n['uuid1', 'uuid2', 'uuid3']</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_uuids(self) -&gt; list[str]:  # numpydoc ignore=ES01\n    \"\"\"\n    Retrieve UUIDs of consumption units registered in the account.\n\n    Returns\n    -------\n    list[str]\n        A list containing UUIDs of consumption units. Each UUID represents a consumption unit,\n        which could be a flat or a house for which consumption readings are provided.\n\n    Notes\n    -----\n    A consumption unit represents a residence or building where consumption readings are recorded.\n    The UUIDs are extracted from the `_residentAndConsumptionUuidsMap` attribute.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; uuids = client.get_uuids()\n    &gt;&gt;&gt; print(uuids)\n    ['uuid1', 'uuid2', 'uuid3']\n    \"\"\"\n    return list(self._account.get(\"residentAndConsumptionUuidsMap\", {}).values())</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw","title":"consum_raw","text":"<pre><code>consum_raw(select_year: list[int] | None = None, select_month: list[int] | None = None, filter_none: bool = True, obj_uuid: str | None = None) -&gt; dict[str, Any] | ConsumptionsResponse</code></pre> <p>Process and filter consumption and cost data for a given consumption unit.</p> <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | ConsumptionsResponse</code>           \u2013            <p>Processed data including consumption types, total additional values, last values, last costs, sum by year, and last year compared consumption.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an unexpected error during data processing.</p> </li> </ul> Notes <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = PyEcotrendIsta()\n&gt;&gt;&gt; result = api.consum_raw(select_year=[2023], select_month=[7], filter_none=True, obj_uuid=\"uuid\")\n&gt;&gt;&gt; print(result)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def consum_raw(  # noqa: C901\n    self,\n    select_year: list[int] | None = None,\n    select_month: list[int] | None = None,\n    filter_none: bool = True,\n    obj_uuid: str | None = None,\n) -&gt; dict[str, Any] | ConsumptionsResponse:  # noqa: C901\n    \"\"\"\n    Process and filter consumption and cost data for a given consumption unit.\n\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Parameters\n    ----------\n    select_year : list[int] | None, optional\n        List of years to filter data by year, default is None.\n    select_month : list[int] | None, optional\n        List of months to filter data by month, default is None.\n    filter_none : bool, optional\n        Whether to filter out None values in readings, default is True.\n    obj_uuid : str | None, optional\n        UUID of the consumption unit to fetch data for, default is None.\n\n    Returns\n    -------\n    dict[str, Any] | ConsumptionsResponse\n        Processed data including consumption types, total additional values, last values,\n        last costs, sum by year, and last year compared consumption.\n\n    Raises\n    ------\n    Exception\n        If there is an unexpected error during data processing.\n\n    Notes\n    -----\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = PyEcotrendIsta()\n    &gt;&gt;&gt; result = api.consum_raw(select_year=[2023], select_month=[7], filter_none=True, obj_uuid=\"uuid\")\n    &gt;&gt;&gt; print(result)\n    \"\"\"\n    # Fetch raw consumption data for the specified UUID\n    c_raw: ConsumptionsResponse = self.get_consumption_data(obj_uuid)\n\n    if not isinstance(c_raw, dict) or (c_raw.get(\"consumptions\") is None and c_raw.get(\"costs\") is None):\n        return c_raw\n\n    if \"consumptions\" not in c_raw or not isinstance(c_raw.get(\"consumptions\"), list):\n        c_raw[\"consumptions\"] = []\n\n    consum_types = []\n    all_dates = []\n    indices_to_delete_consumption = []\n\n    for i, consumption in enumerate(c_raw.get(\"consumptions\", [])):\n        if (\n            not isinstance(consumption, dict)\n            or \"readings\" not in consumption\n            or consumption.get(\"readings\") is None\n            or not isinstance(consumption.get(\"readings\"), list)\n        ):\n            consumption = {}\n            continue\n\n        for reading in consumption.get(\"readings\", []):\n            if reading[\"additionalValue\"] is not None or reading[\"value\"] is not None:\n                consum_types.append(reading[\"type\"])\n\n        consum_types = list({consum_type for consum_type in consum_types if i is not None})\n\n        new_readings = []\n        if \"date\" in consumption:\n            all_dates.append(consumption[\"date\"])\n        if select_month is None and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif (\n            select_year is not None\n            and select_month is not None\n            and consumption[\"date\"][\"year\"] in select_year\n            and consumption[\"date\"][\"month\"] in select_month\n        ):\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_year is not None and consumption[\"date\"][\"year\"] in select_year and select_month is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_month is not None and consumption[\"date\"][\"month\"] in select_month and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        if new_readings:\n            consumption[\"readings\"] = new_readings\n        else:\n            indices_to_delete_consumption.append(i)\n\n    for index in sorted(indices_to_delete_consumption, reverse=True):\n        if index &lt; len(c_raw[\"consumptions\"]):\n            del c_raw[\"consumptions\"][index]\n\n    _all_date = all_dates\n    new_date = []\n    sum_by_year = {}\n    for date in _all_date:\n        if select_year is None or date[\"year\"] in select_year:\n            new_date.append(date[\"year\"])\n    new_date = list(dict.fromkeys(new_date))\n\n    cost_consum_types = consum_types\n\n    sum_by_year = {typ: {year: 0.0 for year in new_date} for typ in cost_consum_types}\n\n    # pylint: disable=too-many-nested-blocks\n    for item in c_raw.get(\"consumptions\", []):\n        if \"readings\" not in item or not item[\"readings\"]:\n            continue\n        for reading in item.get(\"readings\", []):\n            if reading.get(\"type\", None) is None:\n                continue\n            for typ in cost_consum_types:\n                for year in new_date:\n                    if reading[\"type\"] == typ and item[\"date\"][\"year\"] == year:\n                        if reading[\"value\"]:\n                            sum_by_year[typ][year] += round(\n                                float(reading[\"value\"].replace(\",\", \".\")),\n                                1,\n                            )\n                        else:\n                            sum_by_year[typ][year] += round(\n                                (\n                                    float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                                    if reading[\"additionalValue\"] is not None\n                                    else 0.0\n                                ),\n                                1,\n                            )\n\n                        if reading[\"type\"] == \"warmwater\":\n                            sum_by_year[\"ww\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"water\":\n                            sum_by_year[\"w\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                            sum_by_year[\"h\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\":\n                            sum_by_year[\"h\"] = reading[\"additionalUnit\"]\n\n    indices_to_delete_costs = []\n\n    if \"costs\" not in c_raw or not isinstance(c_raw.get(\"costs\"), list):\n        c_raw[\"costs\"] = []\n\n    for i, costs in enumerate(c_raw.get(\"costs\", [])):\n        new_readings = []\n        if \"costsByEnergyType\" in costs:\n            if select_month is None and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif (\n                select_year is not None\n                and select_month is not None\n                and costs[\"date\"][\"year\"] in select_year\n                and costs[\"date\"][\"month\"] in select_month\n            ):\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_year is not None and costs[\"date\"][\"year\"] in select_year and select_month is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_month is not None and costs[\"date\"][\"month\"] in select_month and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n        if new_readings:\n            costs[\"costsByEnergyType\"] = new_readings\n        else:\n            indices_to_delete_costs.append(i)\n    for index in sorted(indices_to_delete_costs, reverse=True):\n        if \"costs\" in c_raw and index &lt; len(c_raw[\"costs\"]):\n            del c_raw[\"costs\"][index]\n\n    for key in [\n        \"consumptionsBillingPeriods\",\n        \"costsBillingPeriods\",\n        \"resident\",\n        \"co2Emissions\",\n        \"co2EmissionsBillingPeriods\",\n    ]:\n        if key in c_raw:\n            del c_raw[key]\n\n    consumptions: list = c_raw.get(\"consumptions\", [])\n    costs: list = c_raw.get(\"costs\", [])\n\n    combined_data = []\n    for cost_entry in costs:\n        for consumption_entry in consumptions:\n            # \u00dcberpr\u00fcfen, ob die Daten das gleiche Datum haben\n            if cost_entry[\"date\"] == consumption_entry[\"date\"]:\n                # Wenn ja, kombiniere die Kosten- und Verbrauchsdaten in einem Eintrag\n                combined_entry = {\n                    \"date\": cost_entry[\"date\"],\n                    \"consumptions\": consumption_entry[\"readings\"],\n                    \"costs\": cost_entry[\"costsByEnergyType\"],\n                }\n\n                combined_data.append(combined_entry)\n\n    total_additional_values = {}\n    total_additional_custom_values = {}\n    for consumption_unit in consumptions:\n        if \"readings\" not in consumption_unit or not consumption_unit[\"readings\"]:\n            continue\n        for reading in consumption_unit.get(\"readings\", []):\n            if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                continue\n\n            if reading[\"type\"] not in total_additional_custom_values:\n                total_additional_custom_values[reading[\"type\"]] = 0.0\n            if reading[\"additionalValue\"]:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    float(reading[\"additionalValue\"].replace(\",\", \".\")), 1\n                )\n            else:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    (float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_custom_values[\"ww\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_custom_values[\"w\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                total_additional_custom_values[\"h\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_custom_values[\"h\"] = reading[\"unit\"]\n\n            if reading[\"type\"] not in total_additional_values:\n                total_additional_values[reading[\"type\"]] = 0.0\n            if reading[\"value\"]:\n                total_additional_values[reading[\"type\"]] += round(float(reading[\"value\"].replace(\",\", \".\")), 1)\n            else:\n                total_additional_values[reading[\"type\"]] += round(\n                    (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    ),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_values[\"ww\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_values[\"w\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                total_additional_values[\"h\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_values[\"h\"] = reading[\"additionalUnit\"]\n\n    last_value = None\n    last_custom_value = None\n    last_year_compared_consumption = None\n\n    if consumptions:\n        last_value = {}\n        last_custom_value = {}\n        last_year_compared_consumption = {}\n\n        if len(consumptions) &gt; 0 and \"readings\" in consumptions[0] and consumptions[0][\"readings\"]:\n            for reading in consumptions[0][\"readings\"]:\n                if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                    continue\n\n                if reading[\"comparedConsumption\"]:\n                    last_year_compared_consumption[reading[\"type\"]] = reading[\"comparedConsumption\"]\n                    last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"] = float(\n                        last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"].replace(\",\", \".\")\n                    )\n\n                    if reading[\"value\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"value\"].replace(\",\", \".\")\n                        )\n                    elif reading[\"additionalValue\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"additionalValue\"].replace(\",\", \".\")\n                        )\n                    if \"period\" in last_year_compared_consumption[reading[\"type\"]]:\n                        del last_year_compared_consumption[reading[\"type\"]][\"period\"]\n\n                if reading[\"type\"] not in last_custom_value:\n                    last_custom_value[reading[\"type\"]] = 0.0\n                if reading[\"additionalValue\"]:\n                    last_custom_value[reading[\"type\"]] += float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                else:\n                    last_custom_value[reading[\"type\"]] += (\n                        float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0\n                    )\n\n                if reading[\"type\"] == \"warmwater\":\n                    last_custom_value[\"ww\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_custom_value[\"w\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_custom_value[\"h\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_custom_value[\"h\"] = reading[\"unit\"]\n\n                if reading[\"type\"] not in last_value:\n                    last_value[reading[\"type\"]] = 0.0\n                if reading[\"value\"]:  # reading[\"type\"] in (\"warmwater\", \"water\", \"heating\") and\n                    last_value[reading[\"type\"]] += float(reading[\"value\"].replace(\",\", \".\"))\n                else:\n                    last_value[reading[\"type\"]] += (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    )\n                if reading[\"type\"] == \"warmwater\":\n                    last_value[\"ww\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_value[\"w\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_value[\"h\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_value[\"h\"] = reading[\"additionalUnit\"]\n\n        last_custom_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_custom_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n        last_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n    last_costs = None\n    if costs:\n        if last_costs is None:\n            last_costs = {}\n        for costs_by_energy_type in costs[0][\"costsByEnergyType\"]:\n            # pylint: disable=too-many-boolean-expressions\n            if (\n                costs_by_energy_type is None\n                or \"type\" not in costs_by_energy_type\n                or costs_by_energy_type[\"type\"] is None\n                or \"comparedCost\" not in costs_by_energy_type\n                or costs_by_energy_type[\"comparedCost\"] is None\n                or \"smiley\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"smiley\"] is None\n                or \"comparedPercentage\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] is None\n            ):\n                continue\n\n            if costs_by_energy_type[\"type\"] not in last_costs:\n                last_costs[costs_by_energy_type[\"type\"]] = 0.0\n            last_costs[costs_by_energy_type[\"type\"]] += costs_by_energy_type[\"value\"]\n            last_costs[\"unit\"] = costs_by_energy_type[\"unit\"]\n            if costs_by_energy_type[\"type\"] == \"warmwater\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"water\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"heating\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n        last_costs[\"month\"] = costs[0][\"date\"][\"month\"]\n        last_costs[\"year\"] = costs[0][\"date\"][\"year\"]\n\n    return CustomRaw.from_dict(\n        {\n            \"consum_types\": consum_types,\n            \"combined_data\": None,  # combined_data,\n            \"total_additional_values\": total_additional_values,\n            \"total_additional_custom_values\": total_additional_custom_values,\n            \"last_value\": last_value,\n            \"last_custom_value\": last_custom_value,\n            \"last_costs\": last_costs,\n            \"all_dates\": None,  # all_dates,\n            \"sum_by_year\": sum_by_year,\n            \"last_year_compared_consumption\": last_year_compared_consumption,\n        }\n    ).to_dict()</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw(select_year)","title":"<code>select_year</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of years to filter data by year, default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw(select_month)","title":"<code>select_month</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of months to filter data by month, default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw(filter_none)","title":"<code>filter_none</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to filter out None values in readings, default is True.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.consum_raw(obj_uuid)","title":"<code>obj_uuid</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>UUID of the consumption unit to fetch data for, default is None.</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_consumption_data","title":"get_consumption_data","text":"<pre><code>get_consumption_data(obj_uuid: str | None = None) -&gt; ConsumptionsResponse</code></pre> <p>Fetch consumption data from the API for a specific consumption unit.</p> <p>This method sends a GET request to the ista EcoTrend API to retrieve consumption data for a specific consumption unit identified by the provided UUID. If no UUID is provided, the method uses the UUID associated with the instance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A dictionary containing the consumption data fetched from the API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an error indicating authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the provided UUID is invalid.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = PyEcotrendIsta()\n&gt;&gt;&gt; data = api.get_consumption_data(obj_uuid=\"uuid\")\n&gt;&gt;&gt; print(data)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_data(self, obj_uuid: str | None = None) -&gt; ConsumptionsResponse:\n    \"\"\"\n    Fetch consumption data from the API for a specific consumption unit.\n\n    This method sends a GET request to the ista EcoTrend API to retrieve consumption data\n    for a specific consumption unit identified by the provided UUID. If no UUID is provided,\n    the method uses the UUID associated with the instance.\n\n    Parameters\n    ----------\n    obj_uuid : str, optional\n        The UUID of the consumption unit. If not provided,\n        defaults to the UUID associated with the instance (`self._uuid`).\n\n    Returns\n    -------\n    ConsumptionsResponse\n        A dictionary containing the consumption data fetched from the API.\n\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an error indicating authorization failure.\n    ParserError\n        If there is an error parsing the request response.\n    ValueError\n        If the provided UUID is invalid.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = PyEcotrendIsta()\n    &gt;&gt;&gt; data = api.get_consumption_data(obj_uuid=\"uuid\")\n    &gt;&gt;&gt; print(data)\n    \"\"\"\n    params = {\"consumptionUnitUuid\": obj_uuid or self._uuid}\n    url = f\"{API_BASE_URL}consumptions\"\n    try:\n        with self.session.get(\n            url,\n            params=params,\n            headers=self._header,\n        ) as result:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, result.status_code, result.text[:100])\n            result.raise_for_status()\n            try:\n                return cast(ConsumptionsResponse, result.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\"Loading consumption data failed due to an error parsing the request response\") from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption data failed failed due to an authorization failure\") from exc\n        if exc.response.status_code == HTTPStatus.BAD_REQUEST:\n            raise ValueError(\n                f\"Invalid UUID. Retrieving data for consumption unit {obj_uuid or self._uuid} failed\"\n            ) from exc\n        raise ServerError(\n            \"Loading consumption data failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption data failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption data failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_consumption_data(obj_uuid)","title":"<code>obj_uuid</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The UUID of the consumption unit. If not provided, defaults to the UUID associated with the instance (<code>self._uuid</code>).</p>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_consumption_unit_details","title":"get_consumption_unit_details","text":"<pre><code>get_consumption_unit_details() -&gt; ConsumptionUnitDetailsResponse</code></pre> <p>Retrieve details of the consumption unit from the API.</p> <p>Returns:</p> <ul> <li> <code>ConsumptionUnitDetailsResponse</code>           \u2013            <p>A dictionary containing the details of the consumption unit.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an issue with decoding the JSON response</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_unit_details(self) -&gt; ConsumptionUnitDetailsResponse:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve details of the consumption unit from the API.\n\n    Returns\n    -------\n    ConsumptionUnitDetailsResponse\n        A dictionary containing the details of the consumption unit.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an authorization failure.\n    ParserError\n        If there is an issue with decoding the JSON response\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n    \"\"\"\n    url = f\"{API_BASE_URL}menu\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionUnitDetailsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption unit details failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption unit details failed failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading consumption unit details failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption unit details failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption unit details failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_support_code","title":"get_support_code","text":"<pre><code>get_support_code() -&gt; str | None</code></pre> <p>Return the support code associated with the instance.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The support code associated with the instance, or None if not set.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_support_code(self) -&gt; str | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Return the support code associated with the instance.\n\n    Returns\n    -------\n    str or None\n        The support code associated with the instance, or None if not set.\n    \"\"\"\n    return getattr(self, \"_account\", {}).get(\"supportCode\")</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_user_agent","title":"get_user_agent","text":"<pre><code>get_user_agent() -&gt; str</code></pre> <p>Return the User-Agent string used for HTTP requests.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The User-Agent string.</p> </li> </ul> Notes <p>This method provides a static User-Agent string commonly used for web browsers.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_user_agent(self) -&gt; str:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Return the User-Agent string used for HTTP requests.\n\n    Returns\n    -------\n    str\n        The User-Agent string.\n\n    Notes\n    -----\n    This method provides a static User-Agent string commonly used for web browsers.\n    \"\"\"\n    return (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67\"\n        \" Safari/537.36\"\n    )</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.demo_user_login","title":"demo_user_login","text":"<pre><code>demo_user_login() -&gt; GetTokenResponse</code></pre> <p>Retrieve authentication tokens for the demo user.</p> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def demo_user_login(self) -&gt; GetTokenResponse:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve authentication tokens for the demo user.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n    \"\"\"\n    url = f\"{API_BASE_URL}demo-user-token\"\n    try:\n        self._header[\"User-Agent\"] = self.get_user_agent()\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                data = r.json()\n                key = iter(GetTokenResponse.__annotations__)\n                token = {next(key): value for value in data.values()}\n                return cast(GetTokenResponse, token)\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\"Demo user authentication failed due to an error parsing the request response\") from exc\n    except requests.HTTPError as exc:\n        raise ServerError(\n            \"Demo user authentication failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Demo user authentication failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Demo user authentication failed due to a request exception\") from exc</code></pre>"},{"location":"#pyecotrend_ista.PyEcotrendIsta.get_account","title":"get_account","text":"<pre><code>get_account() -&gt; AccountResponse | None</code></pre> <p>Retrieve the account information.</p> <p>Returns the <code>_account</code> attribute if it exists, otherwise returns None.</p> <p>Returns:</p> <ul> <li> <code>AccountResponse | None</code>           \u2013            <p>Account information if available, otherwise None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_account(self) -&gt; AccountResponse | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve the account information.\n\n    Returns the `_account` attribute if it exists, otherwise returns None.\n\n    Returns\n    -------\n    AccountResponse | None\n        Account information if available, otherwise None.\n    \"\"\"\n    return getattr(self, \"_account\", None)</code></pre>"},{"location":"#pyecotrend_ista.ConsumptionsResponse","title":"ConsumptionsResponse","text":"<p>A TypedDict representing the response structure for consumption data.</p> <p>Attributes:</p> <ul> <li> <code>co2Emissions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different periods.</p> </li> <li> <code>co2EmissionsBillingPeriods</code>               (<code>list[IstaBillingPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different billing periods.</p> </li> <li> <code>consumptionUnitId</code>               (<code>str</code>)           \u2013            <p>The unique identifier for the consumption unit.</p> </li> <li> <code>consumptions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of consumption data over different periods.</p> </li> <li> <code>consumptionsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The consumption data over different billing periods.</p> </li> <li> <code>costs</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of cost data over different periods.</p> </li> <li> <code>costsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The cost data over different billing periods.</p> </li> <li> <code>isSCEedBasicForCurrentMonth</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the current month.</p> </li> <li> <code>nonEEDBasicStartDate</code>               (<code>Any</code>)           \u2013            <p>The start date for non-EED basic plan (data type unknown).</p> </li> <li> <code>resident</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary containing resident information.</p> </li> </ul>"},{"location":"exception_classes/","title":"Exceptions","text":""},{"location":"exception_classes/#pyecotrend_ista.exception_classes","title":"pyecotrend_ista.exception_classes","text":"<p>Exception Class.</p> <p>Classes:</p> <ul> <li> <code>BaseError</code>           \u2013            <p>Base class for exceptions in this module.</p> </li> <li> <code>ServerError</code>           \u2013            <p>Exception raised for server errors during requests.</p> </li> <li> <code>LoginError</code>           \u2013            <p>Exception raised for login- and authentication related errors.</p> </li> <li> <code>ParserError</code>           \u2013            <p>Exception raised for errors encountered during parsing.</p> </li> <li> <code>KeycloakError</code>           \u2013            <p>Base class for custom Keycloak errors.</p> </li> <li> <code>KeycloakAuthenticationError</code>           \u2013            <p>Keycloak authentication error exception.</p> </li> <li> <code>KeycloakOperationError</code>           \u2013            <p>Keycloak operation error exception.</p> </li> <li> <code>KeycloakGetError</code>           \u2013            <p>Keycloak request get error exception.</p> </li> <li> <code>KeycloakPostError</code>           \u2013            <p>Keycloak request post error exception.</p> </li> <li> <code>KeycloakCodeNotFound</code>           \u2013            <p>Keycloak Code not found exception.</p> </li> <li> <code>KeycloakInvalidTokenError</code>           \u2013            <p>Keycloak invalid token exception.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>deprecated</code>             \u2013              <p>Decorate a function as deprecated and emit a warning when called.</p> </li> </ul>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.BaseError","title":"BaseError","text":"<p>Base class for exceptions in this module.</p> <p>This is the base class for all custom exceptions in the module. It inherits from Python's built-in Exception class and can be used to catch errors specific to this module.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ServerError","title":"ServerError","text":"<p>Exception raised for server errors during requests.</p> <p>This exception is raised when a exception occurs during a request. It inherits from BaseError  and can be used to handle server-related issues specifically.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of the error..</p> </li> </ul>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ServerError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of the error..</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the error..\"\"\"\n    return \"Server error occurred during the request\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.LoginError","title":"LoginError","text":"<p>Exception raised for login- and authentication related errors.</p> <p>This exception is raised when an authentication exception occurs during a request. It inherits from BaseError and is used specifically to handle issues related to authentication and login.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of an authentication error.</p> </li> </ul>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.LoginError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of an authentication error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of an authentication error.\"\"\"\n    return \"An authentication error occurred during the request\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ParserError","title":"ParserError","text":"<p>Exception raised for errors encountered during parsing.</p> <p>This exception is raised when an error occurs during the parsing process of the request response. It inherits from BaseError and can be used to handle issues specifically related to parsing.</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Return a string representation of parser error.</p> </li> </ul>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.ParserError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str</code></pre> <p>Return a string representation of parser error.</p> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of parser error.\"\"\"\n    return \"Error occurred during parsing of the request response\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError","title":"KeycloakError","text":"<pre><code>KeycloakError(error_message='', response_code=None, response_body=None)</code></pre> <p>Base class for custom Keycloak errors.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError","title":"KeycloakAuthenticationError","text":"<pre><code>KeycloakAuthenticationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak authentication error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakAuthenticationError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError","title":"KeycloakOperationError","text":"<pre><code>KeycloakOperationError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak operation error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakOperationError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError","title":"KeycloakGetError","text":"<pre><code>KeycloakGetError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request get error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakGetError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError","title":"KeycloakPostError","text":"<pre><code>KeycloakPostError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak request post error exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakPostError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound","title":"KeycloakCodeNotFound","text":"<pre><code>KeycloakCodeNotFound(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak Code not found exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakCodeNotFound.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError","title":"KeycloakInvalidTokenError","text":"<pre><code>KeycloakInvalidTokenError(error_message='', response_code=None, response_body=None)</code></pre> <p>Keycloak invalid token exception.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Str method.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __init__(self, error_message=\"\", response_code=None, response_body=None):  # numpydoc ignore=ES01,EX01\n    \"\"\"Init method.\n\n    Parameters\n    ----------\n    error_message : str, optional\n        The error message (default is an empty string).\n    response_code : int, optional\n        The code of the response (default is None).\n    response_body : bytes, optional\n        Body of the response (default is None).\n    \"\"\"\n    Exception.__init__(self, error_message)\n\n    self.response_code = response_code\n    self.response_body = response_body\n    self.error_message = error_message</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError(error_message)","title":"<code>error_message</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The error message (default is an empty string).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError(response_code)","title":"<code>response_code</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The code of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError(response_body)","title":"<code>response_body</code>","text":"(<code>bytes</code>, default:                   <code>None</code> )           \u2013            <p>Body of the response (default is None).</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.KeycloakInvalidTokenError.__str__","title":"__str__","text":"<pre><code>__str__()</code></pre> <p>Str method.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String representation of the object.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def __str__(self):\n    \"\"\"Str method.\n\n    Returns\n    -------\n    str\n        String representation of the object.\n    \"\"\"\n    if self.response_code is not None:\n        return f\"{self.response_code}: {self.error_message}\"\n    return f\"{self.error_message}\"</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.deprecated","title":"deprecated","text":"<pre><code>deprecated(func: Callable[..., T], alias_func: str | None = None) -&gt; Callable[..., T]</code></pre> <p>Decorate a function as deprecated and emit a warning when called.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[..., T]</code>           \u2013            <p>A wrapper function that emits a deprecation warning when called.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/exception_classes.py</code> <pre><code>def deprecated(func: Callable[..., T], alias_func: str | None = None) -&gt; Callable[..., T]:  # numpydoc ignore=ES01,PR01,PR02,PR04,PR10,EX01\n    \"\"\"\n    Decorate a function as deprecated and emit a warning when called.\n\n    Parameters\n    ----------\n    func: Callable[..., T])\n        The function to be marked as deprecated.\n    alias_func : str, optional\n        The real function name to show as deprecated, in case the function was called\n        through an alias.\n\n    Returns\n    -------\n    Callable[..., T]\n        A wrapper function that emits a deprecation warning when called.\n\n    \"\"\"\n\n    def deprecated_func(*args, **kwargs):  # numpydoc ignore=ES01,SA01,EX01\n        \"\"\"\n        Emit a deprecation warning and call the decorated function.\n\n        Parameters\n        ----------\n        *args : tuple\n            Positional arguments passed to the decorated function.\n        **kwargs : dict\n            Keyword arguments passed to the decorated function.\n\n        Returns\n        -------\n        T\n            The return value of the decorated function.\n        \"\"\"\n        if alias_func:\n            warning_message = (\n                f\"The `{alias_func}` function is deprecated and will be removed in a future release. \"\n                f\"Use `{func.__name__}` instead.\"\n            )\n        else:\n            warning_message = f\"The `{func.__name__}` function is deprecated and will be removed in a future release.\"\n\n        warnings.warn(warning_message, category=DeprecationWarning, stacklevel=2)\n        return func(*args, **kwargs)\n\n    return deprecated_func</code></pre>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.deprecated(func)","title":"<code>func</code>","text":"(<code>Callable[..., T]</code>)           \u2013            <p>The function to be marked as deprecated.</p>"},{"location":"exception_classes/#pyecotrend_ista.exception_classes.deprecated(alias_func)","title":"<code>alias_func</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The real function name to show as deprecated, in case the function was called through an alias.</p>"},{"location":"login_helper/","title":"Login Helper","text":""},{"location":"login_helper/#pyecotrend_ista.login_helper","title":"pyecotrend_ista.login_helper","text":"<p>Login helper for Keycloak.</p> <p>Classes:</p> <ul> <li> <code>LoginHelper</code>           \u2013            <p>Login helper for Keycloak.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>raise_error_from_response</code>             \u2013              <p>Raise an exception for the response.</p> </li> </ul>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper","title":"LoginHelper","text":"<pre><code>LoginHelper(username: str, password: str, totp: str | None = None, session: Session | None = None, logger=None)</code></pre> <p>Login helper for Keycloak.</p> <p>Attributes:</p> <ul> <li> <code>session</code>               (<code>Session</code>)           \u2013            <p>Optional session object for making HTTP requests.</p> </li> <li> <code>username</code>               (<code>str</code>)           \u2013            <p>Username for authentication.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>Password for authentication.</p> </li> <li> <code>cookie</code>               (<code>str</code>)           \u2013            <p>Authentication cookie.</p> </li> <li> <code>auth_code</code>               (<code>str</code>)           \u2013            <p>Authorization code.</p> </li> <li> <code>form_action</code>               (<code>str</code>)           \u2013            <p>Form action URL for authentication.</p> </li> </ul> Notes <p>This class provides utility methods for handling authentication and session management using Keycloak.</p> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>refresh_token</code>             \u2013              <p>Refresh the access token using the provided refresh token.</p> </li> <li> <code>get_token</code>             \u2013              <p>Retrieve access and refresh tokens using the obtained authorization code.</p> </li> <li> <code>userinfo</code>             \u2013              <p>Retrieve user information from the Keycloak provider.</p> </li> <li> <code>logout</code>             \u2013              <p>Log out the user session from the identity provider.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n    logger=None,\n) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"Initialize the object with username and password.\n\n    Parameters\n    ----------\n    username : str\n        Username for authentication.\n    password : str\n        Password for authentication.\n    totp : str, optional\n        Time-based One-Time Password if enabled, by default None.\n    session : requests.Session, optional\n        Optional session object for making HTTP requests, by default None.\n    logger : logging.Logger, optional\n        Logger object for logging messages, by default None.\n\n    \"\"\"\n    self.username: str = username\n    self.password: str = password\n    self.totp: str | None = totp\n\n    self.session = session or requests.Session()\n\n    self.session.verify = True\n    retries = Retry(total=5, backoff_factor=1, status_forcelist=[502, 503, 504, 408])\n    self.session.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\n    self.logger = logger or logging.getLogger(__name__)</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username for authentication.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper(password)","title":"<code>password</code>","text":"(<code>str</code>)           \u2013            <p>Password for authentication.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper(totp)","title":"<code>totp</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Time-based One-Time Password if enabled, by default None.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper(session)","title":"<code>session</code>","text":"(<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>Optional session object for making HTTP requests, by default None.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>Logger object for logging messages, by default None.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.refresh_token","title":"refresh_token","text":"<pre><code>refresh_token(refresh_token) -&gt; tuple</code></pre> <p>Refresh the access token using the provided refresh token.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, int, str]</code>           \u2013            <p>Tuple containing the refreshed access token, its expiration time in seconds, and the new refresh token.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def refresh_token(self, refresh_token) -&gt; tuple:  # numpydoc ignore=ES01,EX01\n    \"\"\"Refresh the access token using the provided refresh token.\n\n    Parameters\n    ----------\n    refresh_token : str\n        The refresh token obtained from previous authentication.\n\n    Returns\n    -------\n    tuple[str, int, str]\n        Tuple containing the refreshed access token, its expiration time in seconds,\n        and the new refresh token.\n    \"\"\"\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}token\",\n        data={\n            \"grant_type\": GRANT_TYPE_REFRESH_TOKEN,\n            \"client_id\": CLIENT_ID,  # ecotrend\n            \"refresh_token\": refresh_token,\n        },\n    )\n\n    result = resp.json()\n\n    return result[\"access_token\"], result[\"expires_in\"], result[\"refresh_token\"]</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.refresh_token(refresh_token)","title":"<code>refresh_token</code>","text":"(<code>str</code>)           \u2013            <p>The refresh token obtained from previous authentication.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.get_token","title":"get_token","text":"<pre><code>get_token() -&gt; GetTokenResponse</code></pre> <p>Retrieve access and refresh tokens using the obtained authorization code.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If there's an error during the POST request to retrieve tokens.</p> </li> <li> <code>KeycloakInvalidTokenError</code>             \u2013            <p>If the response status code is not 200, indicating an invalid token.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def get_token(self) -&gt; GetTokenResponse:  # numpydoc ignore=ES01,EX01\n    \"\"\"Retrieve access and refresh tokens using the obtained authorization code.\n\n    Raises\n    ------\n    KeycloakPostError\n        If there's an error during the POST request to retrieve tokens.\n\n    KeycloakInvalidTokenError\n        If the response status code is not 200, indicating an invalid token.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    \"\"\"\n    self._login()\n    _data = {\n        \"grant_type\": GRANT_TYPE_AUTHORIZATION_CODE,\n        \"client_id\": CLIENT_ID,  # ecotrend\n        \"redirect_uri\": REDIRECT_URI,\n        \"code\": self.auth_code,\n    }\n    if self.totp:\n        _data[\"totp\"] = self.totp\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}token\",\n        data=_data,\n        timeout=TIMEOUT,\n        allow_redirects=False,\n    )\n\n    raise_error_from_response(response=resp, error=KeycloakPostError)\n    # If the response code is not 200 raise an exception.\n    if resp.status_code != 200:\n        raise KeycloakInvalidTokenError()\n\n    return cast(GetTokenResponse, resp.json())</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.userinfo","title":"userinfo","text":"<pre><code>userinfo(token) -&gt; Any</code></pre> <p>Retrieve user information from the Keycloak provider.</p> <p>This method sends a GET request to the Keycloak <code>userinfo</code> endpoint using the provided token in the Authorization header. It returns the JSON response containing user information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A dictionary containing the user information if the request is successful, or an empty dictionary if the user is a demo user.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakOperationError</code>             \u2013            <p>If the request fails due to a Keycloak operation error.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def userinfo(self, token) -&gt; Any:  # numpydoc ignore=EX01\n    \"\"\"Retrieve user information from the Keycloak provider.\n\n    This method sends a GET request to the Keycloak `userinfo` endpoint using the provided\n    token in the Authorization header. It returns the JSON response containing user information.\n\n    Parameters\n    ----------\n    token : str\n        The access token to be used for authorization.\n\n    Returns\n    -------\n    Any\n        A dictionary containing the user information if the request is successful, or an empty\n        dictionary if the user is a demo user.\n\n    Raises\n    ------\n    KeycloakOperationError\n        If the request fails due to a Keycloak operation error.\n    \"\"\"\n    if self.username == DEMO_USER_ACCOUNT:\n        return {}\n\n    header = {\"Authorization\": f\"Bearer {token}\"}\n    url = f\"{PROVIDER_URL}userinfo\"\n\n    resp: requests.Response = self._send_request(\"GET\", url=url, headers=header)\n\n    return resp.json()</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.userinfo(token)","title":"<code>token</code>","text":"(<code>str</code>)           \u2013            <p>The access token to be used for authorization.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.logout","title":"logout","text":"<pre><code>logout(token) -&gt; dict | Any | bytes | dict[str, str]</code></pre> <p>Log out the user session from the identity provider.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[dict, Any, bytes, dict[str, str]]</code>           \u2013            <p>Response data from the logout request. The exact type may vary based on the response content.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            <p>If an error occurs during the POST request to logout the user.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def logout(self, token) -&gt; dict | Any | bytes | dict[str, str]:  # numpydoc ignore=ES01,EX01\n    \"\"\"Log out the user session from the identity provider.\n\n    Parameters\n    ----------\n    token : str\n        Refresh token associated with the user session.\n\n    Returns\n    -------\n    Union[dict, Any, bytes, dict[str, str]]\n        Response data from the logout request. The exact type may vary based on the response content.\n\n    Raises\n    ------\n    KeycloakPostError\n        If an error occurs during the POST request to logout the user.\n\n    \"\"\"\n    resp: requests.Response = self._send_request(\n        \"POST\",\n        url=f\"{PROVIDER_URL}logout\",\n        data={\n            \"client_id\": CLIENT_ID,\n            \"refresh_token\": token,\n        },\n    )\n\n    return raise_error_from_response(resp, KeycloakPostError)</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.LoginHelper.logout(token)","title":"<code>token</code>","text":"(<code>str</code>)           \u2013            <p>Refresh token associated with the user session.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response","title":"raise_error_from_response","text":"<pre><code>raise_error_from_response(response: Response, error, expected_codes=None, skip_exists=False) -&gt; dict | Any | bytes | dict[str, str]</code></pre> <p>Raise an exception for the response.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes or dict</code>           \u2013            <p>Content of the response message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeycloakError</code>             \u2013            <p>In case of unexpected status codes.</p> </li> </ul> Notes <p>Source from https://github.com/marcospereirampj/python-keycloak/blob/c98189ca6951f12f1023ed3370c9aaa0d81e4aa4/src/keycloak/exceptions.py</p> Source code in <code>src/pyecotrend_ista/login_helper.py</code> <pre><code>def raise_error_from_response(\n    response: requests.Response, error, expected_codes=None, skip_exists=False\n) -&gt; dict | Any | bytes | dict[str, str]:  # numpydoc ignore=ES01,EX01\n    \"\"\"Raise an exception for the response.\n\n    Parameters\n    ----------\n    response : Response\n        The response object.\n    error : dict or Exception\n        Error object to raise.\n    expected_codes : Sequence[int], optional\n        Set of expected codes, which should not raise the exception.\n    skip_exists : bool, optional\n        Indicates whether the response on already existing object should be ignored.\n\n    Returns\n    -------\n    bytes or dict\n        Content of the response message.\n\n    Raises\n    ------\n    KeycloakError\n        In case of unexpected status codes.\n\n    Notes\n    -----\n    Source from https://github.com/marcospereirampj/python-keycloak/blob/c98189ca6951f12f1023ed3370c9aaa0d81e4aa4/src/keycloak/exceptions.py\n    \"\"\"  # noqa: DAR401,DAR402 pylint: disable=line-too-long\n    if expected_codes is None:\n        expected_codes = [200, 201, 204]\n\n    if response.status_code in expected_codes:\n        if response.status_code == requests.codes[\"no_content\"]:\n            return {}\n\n        try:\n            return response.json()\n        except ValueError:\n            return response.content\n\n    if skip_exists and response.status_code == 409:\n        return {\"msg\": \"Already exists\"}\n\n    try:\n        message = response.json()[\"message\"]\n    except (KeyError, ValueError):\n        message = response.content\n\n    if isinstance(error, dict):\n        error = error.get(response.status_code, KeycloakOperationError)\n    else:\n        if response.status_code == 401:\n            error = KeycloakAuthenticationError\n\n    raise error(error_message=message, response_code=response.status_code, response_body=response.content)</code></pre>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response(response)","title":"<code>response</code>","text":"(<code>Response</code>)           \u2013            <p>The response object.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response(error)","title":"<code>error</code>","text":"(<code>dict or Exception</code>)           \u2013            <p>Error object to raise.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response(expected_codes)","title":"<code>expected_codes</code>","text":"(<code>Sequence[int]</code>, default:                   <code>None</code> )           \u2013            <p>Set of expected codes, which should not raise the exception.</p>"},{"location":"login_helper/#pyecotrend_ista.login_helper.raise_error_from_response(skip_exists)","title":"<code>skip_exists</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates whether the response on already existing object should be ignored.</p>"},{"location":"pyecotrend_ista/","title":"API documentation","text":""},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta","title":"pyecotrend_ista.PyEcotrendIsta","text":"<pre><code>PyEcotrendIsta(email: str, password: str, logger: Logger | None = None, hass_dir: str | None = None, totp: str | None = None, session: Session | None = None)</code></pre> <p>A Python client for interacting with the ista EcoTrend API.</p> <p>This class provides methods to authenticate and interact with the ista EcoTrend API.</p> <p>Attributes:</p> <ul> <li> <code>_account</code>               (<code>AccountResponse</code>)           \u2013            <p>The account information.</p> </li> <li> <code>_uuid</code>               (<code>str</code>)           \u2013            <p>The UUID of the consumption unit.</p> </li> <li> <code>_access_token</code>               (<code>str | None</code>)           \u2013            <p>The access token for API authentication.</p> </li> <li> <code>_refresh_token</code>               (<code>str | None</code>)           \u2013            <p>The refresh token for obtaining new access tokens.</p> </li> <li> <code>_access_token_expires_in</code>               (<code>int</code>)           \u2013            <p>The expiration time of the access token.</p> </li> <li> <code>_header</code>               (<code>dict[str, str]</code>)           \u2013            <p>The headers used in HTTP requests.</p> </li> <li> <code>_support_code</code>               (<code>str | None</code>)           \u2013            <p>The support code for the account.</p> </li> <li> <code>_start_timer</code>               (<code>float</code>)           \u2013            <p>The start time for tracking elapsed time.</p> </li> </ul> <p>Examples:</p> <p>Initialize the client and log in:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()</code></pre> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_version</code>             \u2013              <p>Get the version of the PyEcotrendIsta client.</p> </li> <li> <code>login</code>             \u2013              <p>Perform the login process if not already connected or forced.</p> </li> <li> <code>userinfo</code>             \u2013              <p>Retrieve user information using the provided access token.</p> </li> <li> <code>logout</code>             \u2013              <p>Perform logout operation by invalidating the current session.</p> </li> <li> <code>get_uuids</code>             \u2013              <p>Retrieve UUIDs of consumption units registered in the account.</p> </li> <li> <code>consum_raw</code>             \u2013              <p>Process and filter consumption and cost data for a given consumption unit.</p> </li> <li> <code>get_consumption_data</code>             \u2013              <p>Fetch consumption data from the API for a specific consumption unit.</p> </li> <li> <code>get_consumption_unit_details</code>             \u2013              <p>Retrieve details of the consumption unit from the API.</p> </li> <li> <code>get_support_code</code>             \u2013              <p>Return the support code associated with the instance.</p> </li> <li> <code>get_user_agent</code>             \u2013              <p>Return the User-Agent string used for HTTP requests.</p> </li> <li> <code>demo_user_login</code>             \u2013              <p>Retrieve authentication tokens for the demo user.</p> </li> <li> <code>get_account</code>             \u2013              <p>Retrieve the account information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>access_token</code>           \u2013            <p>Retrieve the access token, refreshing it if necessary.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __init__(\n    self,\n    email: str,\n    password: str,\n    logger: logging.Logger | None = None,\n    hass_dir: str | None = None,\n    totp: str | None = None,\n    session: requests.Session | None = None,\n) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"Initialize the PyEcotrendIsta client.\n\n    Parameters\n    ----------\n    email : str\n        The email address used to log in to the ista EcoTrend API.\n    password : str\n        The password used to log in to the ista EcoTrend API.\n    logger : logging.Logger, optional\n        [DEPRECATED] An optional logger instance for logging messages. Default is None.\n    hass_dir : str, optional\n        [DEPRECATED] An optional directory for Home Assistant configuration. Default is None.\n    totp : str, optional\n        An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.\n    session : requests.Session, optional\n        An optional requests session for making HTTP requests. Default is None.\n    \"\"\"\n    if hass_dir:\n        warnings.warn(\n            \"The 'hass_dir' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if logger:\n        warnings.warn(\n            \"The 'logger' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    self._email: str = email.strip()\n    self._password: str = password\n\n    self.loginhelper = LoginHelper(\n        username=self._email,\n        password=self._password,\n        totp=totp,\n        session=session,\n        logger=_LOGGER,\n    )\n\n    self.session: requests.Session = self.loginhelper.session</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(email)","title":"<code>email</code>","text":"(<code>str</code>)           \u2013            <p>The email address used to log in to the ista EcoTrend API.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(password)","title":"<code>password</code>","text":"(<code>str</code>)           \u2013            <p>The password used to log in to the ista EcoTrend API.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(logger)","title":"<code>logger</code>","text":"(<code>Logger</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional logger instance for logging messages. Default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(hass_dir)","title":"<code>hass_dir</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[DEPRECATED] An optional directory for Home Assistant configuration. Default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(totp)","title":"<code>totp</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>An optional TOTP (Time-based One-Time Password) for two-factor authentication. Default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta(session)","title":"<code>session</code>","text":"(<code>Session</code>, default:                   <code>None</code> )           \u2013            <p>An optional requests session for making HTTP requests. Default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.access_token","title":"access_token  <code>property</code> <code>writable</code>","text":"<pre><code>access_token</code></pre> <p>Retrieve the access token, refreshing it if necessary.</p> <p>This property checks if the access token is still valid. If the token has expired and the client is connected, it refreshes the token. The token is considered expired if the current time minus the start time exceeds the token's expiration period.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The current access token.</p> </li> </ul> Notes <p>This method will automatically refresh the access token if it has expired.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__login","title":"__login","text":"<pre><code>__login() -&gt; str | None</code></pre> <p>Perform the login process to obtain an access token.</p> <p>If the email is a demo account, it logs in using a demo user login function. For other accounts, it retrieves a token using a login helper.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __login(self) -&gt; str | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Perform the login process to obtain an access token.\n\n    If the email is a demo account, it logs in using a demo user login function.\n    For other accounts, it retrieves a token using a login helper.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n    \"\"\"\n    if self._email == DEMO_USER_ACCOUNT:\n        _LOGGER.debug(\"Logging in as demo user\")\n        token = self.demo_user_login()\n    else:\n        token = self.loginhelper.get_token()\n    if token:\n        self.access_token = token[\"access_token\"]\n        self._access_token_expires_in = token[\"expires_in\"]\n        self._refresh_token = token[\"refresh_token\"]\n        return self.access_token\n    return None</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__refresh","title":"__refresh","text":"<pre><code>__refresh() -&gt; None</code></pre> <p>Refresh the access token using the refresh token.</p> <p>This method retrieves a new access token, updates internal variables, and resets the token expiration timer.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If there is an authorization failure.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __refresh(self) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Refresh the access token using the refresh token.\n\n    This method retrieves a new access token, updates internal variables,\n    and resets the token expiration timer.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    LoginError\n        If there is an authorization failure.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n    \"\"\"\n    (\n        self.access_token,\n        self._access_token_expires_in,\n        self._refresh_token,\n    ) = self.loginhelper.refresh_token(self._refresh_token)\n\n    self._header[\"Authorization\"] = f\"Bearer {self.access_token}\"</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.__set_account","title":"__set_account","text":"<pre><code>__set_account() -&gt; None</code></pre> <p>Fetch and set account information from the API.</p> <p>This method performs an API request to retrieve account information, handles various potential errors that might occur during the request, and sets instance variables accordingly using the response data.</p> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the JSON response.</p> </li> <li> <code>LoginError</code>             \u2013            <p>If the request fails due to an authorization error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If the request fails due to a server error, timeout, or other request exceptions.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def __set_account(self) -&gt; None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Fetch and set account information from the API.\n\n    This method performs an API request to retrieve account information,\n    handles various potential errors that might occur during the request,\n    and sets instance variables accordingly using the response data.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the JSON response.\n    LoginError\n        If the request fails due to an authorization error.\n    ServerError\n        If the request fails due to a server error, timeout, or other request exceptions.\n    \"\"\"\n    self._header = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": self.get_user_agent(),\n        \"Authorization\": f\"Bearer {self.access_token}\",\n    }\n    url = f\"{API_BASE_URL}account\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n            r.raise_for_status()\n            try:\n                data = r.json()\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading account information failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading account information failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading account information failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading account information failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading account information failed due to a request exception\") from exc\n\n    self._account = cast(AccountResponse, data)\n    self._uuid = data[\"activeConsumptionUnit\"]</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str</code></pre> <p>Get the version of the PyEcotrendIsta client.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The version number of the PyEcotrendIsta client.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_version(self) -&gt; str:  # numpydoc ignore=EX01,ES01\n    \"\"\"\n    Get the version of the PyEcotrendIsta client.\n\n    Returns\n    -------\n    str\n        The version number of the PyEcotrendIsta client.\n    \"\"\"\n    return VERSION</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.login","title":"login","text":"<pre><code>login(force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None</code></pre> <p>Perform the login process if not already connected or forced.</p> <p>Parameters:</p> Deprecated Parameters <p>forceLogin : bool, optional     Use <code>force_login</code> instead. This parameter is deprecated and will be removed in a future release.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The access token if login is successful, None otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the login process fails due to an error.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If a server error occurs during login attempts.</p> </li> <li> <code>InternalServerError</code>             \u2013            <p>If an internal server error occurs during login attempts.</p> </li> <li> <code>Exception</code>             \u2013            <p>For any other unexpected errors during the login process.</p> </li> </ul> Notes <ul> <li>The <code>forceLogin</code> parameter is handled via <code>**kwargs</code> for backward compatibility.</li> <li>The <code>debug</code> parameter is deprecated; use appropriate logging configuration instead.</li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def login(self, force_login: bool = False, debug: bool = False, **kwargs) -&gt; str | None:  # numpydoc ignore=ES01,EX01,PR01,PR02\n    \"\"\"\n    Perform the login process if not already connected or forced.\n\n    Parameters\n    ----------\n    force_login : bool, optional\n        If True, forces a fresh login attempt even if already connected. Default is False.\n    debug : bool, optional\n        [DEPRECATED] Flag indicating whether to enable debug logging. Default is False.\n\n    Deprecated Parameters\n    ----------------------\n    forceLogin : bool, optional\n        Use `force_login` instead. This parameter is deprecated and will be removed in a future release.\n\n    Returns\n    -------\n    str or None\n        The access token if login is successful, None otherwise.\n\n    Raises\n    ------\n    LoginError\n        If the login process fails due to an error.\n    ServerError\n        If a server error occurs during login attempts.\n    InternalServerError\n        If an internal server error occurs during login attempts.\n    Exception\n        For any other unexpected errors during the login process.\n\n    Notes\n    -----\n    - The `forceLogin` parameter is handled via `**kwargs` for backward compatibility.\n    - The `debug` parameter is deprecated; use appropriate logging configuration instead.\n    \"\"\"\n    if debug:\n        warnings.warn(\n            \"The 'debug' parameter is deprecated and will be removed in a future release.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    if \"forceLogin\" in kwargs:\n        warnings.warn(\n            \"The 'forceLogin' keyword parameter is deprecated and will be removed in a future release. \"\n            \"Use force_login instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        force_login = kwargs[\"forceLogin\"]\n\n    if not self._is_connected() or force_login:\n        try:\n            self.__login()\n            self.__set_account()\n        except (KeycloakError, LoginError) as exc:\n            # Login failed\n            self._access_token = None\n            raise LoginError(\n                \"Login failed due to an authorization failure, please verify your email and password\"\n            ) from exc\n        except ServerError as exc:\n            raise ServerError(\"Login failed due to a request exception, please try again later\") from exc\n\n    return self.access_token</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.login(force_login)","title":"<code>force_login</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, forces a fresh login attempt even if already connected. Default is False.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.login(debug)","title":"<code>debug</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[DEPRECATED] Flag indicating whether to enable debug logging. Default is False.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.userinfo","title":"userinfo","text":"<pre><code>userinfo(token)</code></pre> <p>Retrieve user information using the provided access token.</p> <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>JSON response containing user information.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RequestException</code>             \u2013            <p>If an error occurs while making the HTTP request.</p> </li> </ul> Notes <p>This method constructs an authorization header using the provided access token and sends a GET request to the userinfo endpoint of the provider API. It expects a JSON response with user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; token = client.login()\n&gt;&gt;&gt; user_info = client.userinfo(token)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def userinfo(self, token):\n    \"\"\"\n    Retrieve user information using the provided access token.\n\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API. It expects\n    a JSON response with user information.\n\n    Parameters\n    ----------\n    token : str\n        The access token used for authentication.\n\n    Returns\n    -------\n    Any\n        JSON response containing user information.\n\n    Raises\n    ------\n    requests.exceptions.RequestException\n        If an error occurs while making the HTTP request.\n\n    Notes\n    -----\n    This method constructs an authorization header using the provided access token\n    and sends a GET request to the userinfo endpoint of the provider API.\n    It expects a JSON response with user information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; token = client.login()\n    &gt;&gt;&gt; user_info = client.userinfo(token)\n    \"\"\"\n    return self.loginhelper.userinfo(token=token)</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.userinfo(token)","title":"<code>token</code>","text":"(<code>str</code>)           \u2013            <p>The access token used for authentication.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.logout","title":"logout","text":"<pre><code>logout() -&gt; None</code></pre> <p>Perform logout operation by invalidating the current session.</p> <p>This method invokes the logout functionality in the loginhelper module, passing the current refresh token for session invalidation.</p> <p>Raises:</p> <ul> <li> <code>KeycloakPostError</code>             \u2013            </li> <li> <code>If an error occurs during the logout process. This error is raised based on the response from the logout request.</code>             \u2013            </li> </ul> Notes <p>This method assumes <code>self._refresh_token</code> is already set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()\n&gt;&gt;&gt; client.logout()</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"\n    Perform logout operation by invalidating the current session.\n\n    This method invokes the logout functionality in the loginhelper module,\n    passing the current refresh token for session invalidation.\n\n    Raises\n    ------\n    KeycloakPostError\n    If an error occurs during the logout process. This error is raised based on the response from the logout request.\n\n    Notes\n    -----\n    This method assumes `self._refresh_token` is already set.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; client.logout()\n    \"\"\"\n    if self.loginhelper.username != DEMO_USER_ACCOUNT:\n        self.loginhelper.logout(self._refresh_token)</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_uuids","title":"get_uuids","text":"<pre><code>get_uuids() -&gt; list[str]</code></pre> <p>Retrieve UUIDs of consumption units registered in the account.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list containing UUIDs of consumption units. Each UUID represents a consumption unit, which could be a flat or a house for which consumption readings are provided.</p> </li> </ul> Notes <p>A consumption unit represents a residence or building where consumption readings are recorded. The UUIDs are extracted from the <code>_residentAndConsumptionUuidsMap</code> attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n&gt;&gt;&gt; client.login()\n&gt;&gt;&gt; uuids = client.get_uuids()\n&gt;&gt;&gt; print(uuids)\n['uuid1', 'uuid2', 'uuid3']</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_uuids(self) -&gt; list[str]:  # numpydoc ignore=ES01\n    \"\"\"\n    Retrieve UUIDs of consumption units registered in the account.\n\n    Returns\n    -------\n    list[str]\n        A list containing UUIDs of consumption units. Each UUID represents a consumption unit,\n        which could be a flat or a house for which consumption readings are provided.\n\n    Notes\n    -----\n    A consumption unit represents a residence or building where consumption readings are recorded.\n    The UUIDs are extracted from the `_residentAndConsumptionUuidsMap` attribute.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = PyEcotrendIsta(email=\"user@example.com\", password=\"password\")\n    &gt;&gt;&gt; client.login()\n    &gt;&gt;&gt; uuids = client.get_uuids()\n    &gt;&gt;&gt; print(uuids)\n    ['uuid1', 'uuid2', 'uuid3']\n    \"\"\"\n    return list(self._account.get(\"residentAndConsumptionUuidsMap\", {}).values())</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw","title":"consum_raw","text":"<pre><code>consum_raw(select_year: list[int] | None = None, select_month: list[int] | None = None, filter_none: bool = True, obj_uuid: str | None = None) -&gt; dict[str, Any] | ConsumptionsResponse</code></pre> <p>Process and filter consumption and cost data for a given consumption unit.</p> <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | ConsumptionsResponse</code>           \u2013            <p>Processed data including consumption types, total additional values, last values, last costs, sum by year, and last year compared consumption.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is an unexpected error during data processing.</p> </li> </ul> Notes <p>This method processes consumption and cost data obtained from the <code>get_consumption_data</code> method. It filters and aggregates data based on the parameters provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = PyEcotrendIsta()\n&gt;&gt;&gt; result = api.consum_raw(select_year=[2023], select_month=[7], filter_none=True, obj_uuid=\"uuid\")\n&gt;&gt;&gt; print(result)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def consum_raw(  # noqa: C901\n    self,\n    select_year: list[int] | None = None,\n    select_month: list[int] | None = None,\n    filter_none: bool = True,\n    obj_uuid: str | None = None,\n) -&gt; dict[str, Any] | ConsumptionsResponse:  # noqa: C901\n    \"\"\"\n    Process and filter consumption and cost data for a given consumption unit.\n\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Parameters\n    ----------\n    select_year : list[int] | None, optional\n        List of years to filter data by year, default is None.\n    select_month : list[int] | None, optional\n        List of months to filter data by month, default is None.\n    filter_none : bool, optional\n        Whether to filter out None values in readings, default is True.\n    obj_uuid : str | None, optional\n        UUID of the consumption unit to fetch data for, default is None.\n\n    Returns\n    -------\n    dict[str, Any] | ConsumptionsResponse\n        Processed data including consumption types, total additional values, last values,\n        last costs, sum by year, and last year compared consumption.\n\n    Raises\n    ------\n    Exception\n        If there is an unexpected error during data processing.\n\n    Notes\n    -----\n    This method processes consumption and cost data obtained from the `get_consumption_data` method.\n    It filters and aggregates data based on the parameters provided.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = PyEcotrendIsta()\n    &gt;&gt;&gt; result = api.consum_raw(select_year=[2023], select_month=[7], filter_none=True, obj_uuid=\"uuid\")\n    &gt;&gt;&gt; print(result)\n    \"\"\"\n    # Fetch raw consumption data for the specified UUID\n    c_raw: ConsumptionsResponse = self.get_consumption_data(obj_uuid)\n\n    if not isinstance(c_raw, dict) or (c_raw.get(\"consumptions\") is None and c_raw.get(\"costs\") is None):\n        return c_raw\n\n    if \"consumptions\" not in c_raw or not isinstance(c_raw.get(\"consumptions\"), list):\n        c_raw[\"consumptions\"] = []\n\n    consum_types = []\n    all_dates = []\n    indices_to_delete_consumption = []\n\n    for i, consumption in enumerate(c_raw.get(\"consumptions\", [])):\n        if (\n            not isinstance(consumption, dict)\n            or \"readings\" not in consumption\n            or consumption.get(\"readings\") is None\n            or not isinstance(consumption.get(\"readings\"), list)\n        ):\n            consumption = {}\n            continue\n\n        for reading in consumption.get(\"readings\", []):\n            if reading[\"additionalValue\"] is not None or reading[\"value\"] is not None:\n                consum_types.append(reading[\"type\"])\n\n        consum_types = list({consum_type for consum_type in consum_types if i is not None})\n\n        new_readings = []\n        if \"date\" in consumption:\n            all_dates.append(consumption[\"date\"])\n        if select_month is None and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif (\n            select_year is not None\n            and select_month is not None\n            and consumption[\"date\"][\"year\"] in select_year\n            and consumption[\"date\"][\"month\"] in select_month\n        ):\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_year is not None and consumption[\"date\"][\"year\"] in select_year and select_month is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        elif select_month is not None and consumption[\"date\"][\"month\"] in select_month and select_year is None:\n            for reading in consumption.get(\"readings\", []):\n                if filter_none and reading[\"type\"] is not None:\n                    new_readings.append(reading)\n                elif not filter_none:\n                    new_readings.append(reading)\n        if new_readings:\n            consumption[\"readings\"] = new_readings\n        else:\n            indices_to_delete_consumption.append(i)\n\n    for index in sorted(indices_to_delete_consumption, reverse=True):\n        if index &lt; len(c_raw[\"consumptions\"]):\n            del c_raw[\"consumptions\"][index]\n\n    _all_date = all_dates\n    new_date = []\n    sum_by_year = {}\n    for date in _all_date:\n        if select_year is None or date[\"year\"] in select_year:\n            new_date.append(date[\"year\"])\n    new_date = list(dict.fromkeys(new_date))\n\n    cost_consum_types = consum_types\n\n    sum_by_year = {typ: {year: 0.0 for year in new_date} for typ in cost_consum_types}\n\n    # pylint: disable=too-many-nested-blocks\n    for item in c_raw.get(\"consumptions\", []):\n        if \"readings\" not in item or not item[\"readings\"]:\n            continue\n        for reading in item.get(\"readings\", []):\n            if reading.get(\"type\", None) is None:\n                continue\n            for typ in cost_consum_types:\n                for year in new_date:\n                    if reading[\"type\"] == typ and item[\"date\"][\"year\"] == year:\n                        if reading[\"value\"]:\n                            sum_by_year[typ][year] += round(\n                                float(reading[\"value\"].replace(\",\", \".\")),\n                                1,\n                            )\n                        else:\n                            sum_by_year[typ][year] += round(\n                                (\n                                    float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                                    if reading[\"additionalValue\"] is not None\n                                    else 0.0\n                                ),\n                                1,\n                            )\n\n                        if reading[\"type\"] == \"warmwater\":\n                            sum_by_year[\"ww\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"water\":\n                            sum_by_year[\"w\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                            sum_by_year[\"h\"] = reading[\"unit\"]\n                        elif reading[\"type\"] == \"heating\":\n                            sum_by_year[\"h\"] = reading[\"additionalUnit\"]\n\n    indices_to_delete_costs = []\n\n    if \"costs\" not in c_raw or not isinstance(c_raw.get(\"costs\"), list):\n        c_raw[\"costs\"] = []\n\n    for i, costs in enumerate(c_raw.get(\"costs\", [])):\n        new_readings = []\n        if \"costsByEnergyType\" in costs:\n            if select_month is None and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif (\n                select_year is not None\n                and select_month is not None\n                and costs[\"date\"][\"year\"] in select_year\n                and costs[\"date\"][\"month\"] in select_month\n            ):\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_year is not None and costs[\"date\"][\"year\"] in select_year and select_month is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n            elif select_month is not None and costs[\"date\"][\"month\"] in select_month and select_year is None:\n                for reading in costs.get(\"costsByEnergyType\", []):\n                    if filter_none and reading[\"type\"] is not None:\n                        new_readings.append(reading)\n                    elif not filter_none:\n                        new_readings.append(reading)\n        if new_readings:\n            costs[\"costsByEnergyType\"] = new_readings\n        else:\n            indices_to_delete_costs.append(i)\n    for index in sorted(indices_to_delete_costs, reverse=True):\n        if \"costs\" in c_raw and index &lt; len(c_raw[\"costs\"]):\n            del c_raw[\"costs\"][index]\n\n    for key in [\n        \"consumptionsBillingPeriods\",\n        \"costsBillingPeriods\",\n        \"resident\",\n        \"co2Emissions\",\n        \"co2EmissionsBillingPeriods\",\n    ]:\n        if key in c_raw:\n            del c_raw[key]\n\n    consumptions: list = c_raw.get(\"consumptions\", [])\n    costs: list = c_raw.get(\"costs\", [])\n\n    combined_data = []\n    for cost_entry in costs:\n        for consumption_entry in consumptions:\n            # \u00dcberpr\u00fcfen, ob die Daten das gleiche Datum haben\n            if cost_entry[\"date\"] == consumption_entry[\"date\"]:\n                # Wenn ja, kombiniere die Kosten- und Verbrauchsdaten in einem Eintrag\n                combined_entry = {\n                    \"date\": cost_entry[\"date\"],\n                    \"consumptions\": consumption_entry[\"readings\"],\n                    \"costs\": cost_entry[\"costsByEnergyType\"],\n                }\n\n                combined_data.append(combined_entry)\n\n    total_additional_values = {}\n    total_additional_custom_values = {}\n    for consumption_unit in consumptions:\n        if \"readings\" not in consumption_unit or not consumption_unit[\"readings\"]:\n            continue\n        for reading in consumption_unit.get(\"readings\", []):\n            if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                continue\n\n            if reading[\"type\"] not in total_additional_custom_values:\n                total_additional_custom_values[reading[\"type\"]] = 0.0\n            if reading[\"additionalValue\"]:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    float(reading[\"additionalValue\"].replace(\",\", \".\")), 1\n                )\n            else:\n                total_additional_custom_values[reading[\"type\"]] += round(\n                    (float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_custom_values[\"ww\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_custom_values[\"w\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                total_additional_custom_values[\"h\"] = reading[\"additionalUnit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_custom_values[\"h\"] = reading[\"unit\"]\n\n            if reading[\"type\"] not in total_additional_values:\n                total_additional_values[reading[\"type\"]] = 0.0\n            if reading[\"value\"]:\n                total_additional_values[reading[\"type\"]] += round(float(reading[\"value\"].replace(\",\", \".\")), 1)\n            else:\n                total_additional_values[reading[\"type\"]] += round(\n                    (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    ),\n                    1,\n                )\n\n            if reading[\"type\"] == \"warmwater\":\n                total_additional_values[\"ww\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"water\":\n                total_additional_values[\"w\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\" and reading[\"unit\"]:\n                total_additional_values[\"h\"] = reading[\"unit\"]\n            elif reading[\"type\"] == \"heating\":\n                total_additional_values[\"h\"] = reading[\"additionalUnit\"]\n\n    last_value = None\n    last_custom_value = None\n    last_year_compared_consumption = None\n\n    if consumptions:\n        last_value = {}\n        last_custom_value = {}\n        last_year_compared_consumption = {}\n\n        if len(consumptions) &gt; 0 and \"readings\" in consumptions[0] and consumptions[0][\"readings\"]:\n            for reading in consumptions[0][\"readings\"]:\n                if reading[\"type\"] is None or (reading[\"value\"] is None and reading[\"additionalValue\"] is None):\n                    continue\n\n                if reading[\"comparedConsumption\"]:\n                    last_year_compared_consumption[reading[\"type\"]] = reading[\"comparedConsumption\"]\n                    last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"] = float(\n                        last_year_compared_consumption[reading[\"type\"]][\"comparedValue\"].replace(\",\", \".\")\n                    )\n\n                    if reading[\"value\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"value\"].replace(\",\", \".\")\n                        )\n                    elif reading[\"additionalValue\"]:\n                        last_year_compared_consumption[reading[\"type\"]][\"nowYearValue\"] = float(\n                            reading[\"additionalValue\"].replace(\",\", \".\")\n                        )\n                    if \"period\" in last_year_compared_consumption[reading[\"type\"]]:\n                        del last_year_compared_consumption[reading[\"type\"]][\"period\"]\n\n                if reading[\"type\"] not in last_custom_value:\n                    last_custom_value[reading[\"type\"]] = 0.0\n                if reading[\"additionalValue\"]:\n                    last_custom_value[reading[\"type\"]] += float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                else:\n                    last_custom_value[reading[\"type\"]] += (\n                        float(reading[\"value\"].replace(\",\", \".\")) if reading[\"value\"] is not None else 0.0\n                    )\n\n                if reading[\"type\"] == \"warmwater\":\n                    last_custom_value[\"ww\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_custom_value[\"w\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_custom_value[\"h\"] = reading[\"additionalUnit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_custom_value[\"h\"] = reading[\"unit\"]\n\n                if reading[\"type\"] not in last_value:\n                    last_value[reading[\"type\"]] = 0.0\n                if reading[\"value\"]:  # reading[\"type\"] in (\"warmwater\", \"water\", \"heating\") and\n                    last_value[reading[\"type\"]] += float(reading[\"value\"].replace(\",\", \".\"))\n                else:\n                    last_value[reading[\"type\"]] += (\n                        float(reading[\"additionalValue\"].replace(\",\", \".\"))\n                        if reading[\"additionalValue\"] is not None\n                        else 0.0\n                    )\n                if reading[\"type\"] == \"warmwater\":\n                    last_value[\"ww\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"water\":\n                    last_value[\"w\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\" and reading[\"additionalUnit\"]:\n                    last_value[\"h\"] = reading[\"unit\"]\n                elif reading[\"type\"] == \"heating\":\n                    last_value[\"h\"] = reading[\"additionalUnit\"]\n\n        last_custom_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_custom_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n        last_value[\"month\"] = consumptions[0][\"date\"][\"month\"]\n        last_value[\"year\"] = consumptions[0][\"date\"][\"year\"]\n\n    last_costs = None\n    if costs:\n        if last_costs is None:\n            last_costs = {}\n        for costs_by_energy_type in costs[0][\"costsByEnergyType\"]:\n            # pylint: disable=too-many-boolean-expressions\n            if (\n                costs_by_energy_type is None\n                or \"type\" not in costs_by_energy_type\n                or costs_by_energy_type[\"type\"] is None\n                or \"comparedCost\" not in costs_by_energy_type\n                or costs_by_energy_type[\"comparedCost\"] is None\n                or \"smiley\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"smiley\"] is None\n                or \"comparedPercentage\" not in costs_by_energy_type[\"comparedCost\"]\n                or costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] is None\n            ):\n                continue\n\n            if costs_by_energy_type[\"type\"] not in last_costs:\n                last_costs[costs_by_energy_type[\"type\"]] = 0.0\n            last_costs[costs_by_energy_type[\"type\"]] += costs_by_energy_type[\"value\"]\n            last_costs[\"unit\"] = costs_by_energy_type[\"unit\"]\n            if costs_by_energy_type[\"type\"] == \"warmwater\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"ww\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"water\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] == [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"w\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n            elif costs_by_energy_type[\"type\"] == \"heating\":\n                if costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"MAD\", \"EQUAL\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"]\n                elif costs_by_energy_type[\"comparedCost\"][\"smiley\"] in [\"HAPPY\"]:\n                    last_costs[\"h\"] = costs_by_energy_type[\"comparedCost\"][\"comparedPercentage\"] * -1\n        last_costs[\"month\"] = costs[0][\"date\"][\"month\"]\n        last_costs[\"year\"] = costs[0][\"date\"][\"year\"]\n\n    return CustomRaw.from_dict(\n        {\n            \"consum_types\": consum_types,\n            \"combined_data\": None,  # combined_data,\n            \"total_additional_values\": total_additional_values,\n            \"total_additional_custom_values\": total_additional_custom_values,\n            \"last_value\": last_value,\n            \"last_custom_value\": last_custom_value,\n            \"last_costs\": last_costs,\n            \"all_dates\": None,  # all_dates,\n            \"sum_by_year\": sum_by_year,\n            \"last_year_compared_consumption\": last_year_compared_consumption,\n        }\n    ).to_dict()</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw(select_year)","title":"<code>select_year</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of years to filter data by year, default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw(select_month)","title":"<code>select_month</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of months to filter data by month, default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw(filter_none)","title":"<code>filter_none</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to filter out None values in readings, default is True.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.consum_raw(obj_uuid)","title":"<code>obj_uuid</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>UUID of the consumption unit to fetch data for, default is None.</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_consumption_data","title":"get_consumption_data","text":"<pre><code>get_consumption_data(obj_uuid: str | None = None) -&gt; ConsumptionsResponse</code></pre> <p>Fetch consumption data from the API for a specific consumption unit.</p> <p>This method sends a GET request to the ista EcoTrend API to retrieve consumption data for a specific consumption unit identified by the provided UUID. If no UUID is provided, the method uses the UUID associated with the instance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A dictionary containing the consumption data fetched from the API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an error indicating authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the provided UUID is invalid.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = PyEcotrendIsta()\n&gt;&gt;&gt; data = api.get_consumption_data(obj_uuid=\"uuid\")\n&gt;&gt;&gt; print(data)</code></pre> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_data(self, obj_uuid: str | None = None) -&gt; ConsumptionsResponse:\n    \"\"\"\n    Fetch consumption data from the API for a specific consumption unit.\n\n    This method sends a GET request to the ista EcoTrend API to retrieve consumption data\n    for a specific consumption unit identified by the provided UUID. If no UUID is provided,\n    the method uses the UUID associated with the instance.\n\n    Parameters\n    ----------\n    obj_uuid : str, optional\n        The UUID of the consumption unit. If not provided,\n        defaults to the UUID associated with the instance (`self._uuid`).\n\n    Returns\n    -------\n    ConsumptionsResponse\n        A dictionary containing the consumption data fetched from the API.\n\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an error indicating authorization failure.\n    ParserError\n        If there is an error parsing the request response.\n    ValueError\n        If the provided UUID is invalid.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = PyEcotrendIsta()\n    &gt;&gt;&gt; data = api.get_consumption_data(obj_uuid=\"uuid\")\n    &gt;&gt;&gt; print(data)\n    \"\"\"\n    params = {\"consumptionUnitUuid\": obj_uuid or self._uuid}\n    url = f\"{API_BASE_URL}consumptions\"\n    try:\n        with self.session.get(\n            url,\n            params=params,\n            headers=self._header,\n        ) as result:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, result.status_code, result.text[:100])\n            result.raise_for_status()\n            try:\n                return cast(ConsumptionsResponse, result.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\"Loading consumption data failed due to an error parsing the request response\") from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption data failed failed due to an authorization failure\") from exc\n        if exc.response.status_code == HTTPStatus.BAD_REQUEST:\n            raise ValueError(\n                f\"Invalid UUID. Retrieving data for consumption unit {obj_uuid or self._uuid} failed\"\n            ) from exc\n        raise ServerError(\n            \"Loading consumption data failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption data failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption data failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_consumption_data(obj_uuid)","title":"<code>obj_uuid</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The UUID of the consumption unit. If not provided, defaults to the UUID associated with the instance (<code>self._uuid</code>).</p>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_consumption_unit_details","title":"get_consumption_unit_details","text":"<pre><code>get_consumption_unit_details() -&gt; ConsumptionUnitDetailsResponse</code></pre> <p>Retrieve details of the consumption unit from the API.</p> <p>Returns:</p> <ul> <li> <code>ConsumptionUnitDetailsResponse</code>           \u2013            <p>A dictionary containing the details of the consumption unit.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoginError</code>             \u2013            <p>If the API responds with an authorization failure.</p> </li> <li> <code>ParserError</code>             \u2013            <p>If there is an issue with decoding the JSON response</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_consumption_unit_details(self) -&gt; ConsumptionUnitDetailsResponse:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve details of the consumption unit from the API.\n\n    Returns\n    -------\n    ConsumptionUnitDetailsResponse\n        A dictionary containing the details of the consumption unit.\n\n    Raises\n    ------\n    LoginError\n        If the API responds with an authorization failure.\n    ParserError\n        If there is an issue with decoding the JSON response\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n    \"\"\"\n    url = f\"{API_BASE_URL}menu\"\n    try:\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request: %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                return cast(ConsumptionUnitDetailsResponse, r.json())\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\n                    \"Loading consumption unit details failed due to an error parsing the request response\"\n                ) from exc\n    except requests.HTTPError as exc:\n        if exc.response.status_code == HTTPStatus.UNAUTHORIZED:\n            raise LoginError(\"Loading consumption unit details failed failed due to an authorization failure\") from exc\n\n        raise ServerError(\n            \"Loading consumption unit details failed due to a server error \"\n            f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Loading consumption unit details failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Loading consumption unit details failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_support_code","title":"get_support_code","text":"<pre><code>get_support_code() -&gt; str | None</code></pre> <p>Return the support code associated with the instance.</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>The support code associated with the instance, or None if not set.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_support_code(self) -&gt; str | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Return the support code associated with the instance.\n\n    Returns\n    -------\n    str or None\n        The support code associated with the instance, or None if not set.\n    \"\"\"\n    return getattr(self, \"_account\", {}).get(\"supportCode\")</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_user_agent","title":"get_user_agent","text":"<pre><code>get_user_agent() -&gt; str</code></pre> <p>Return the User-Agent string used for HTTP requests.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The User-Agent string.</p> </li> </ul> Notes <p>This method provides a static User-Agent string commonly used for web browsers.</p> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_user_agent(self) -&gt; str:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Return the User-Agent string used for HTTP requests.\n\n    Returns\n    -------\n    str\n        The User-Agent string.\n\n    Notes\n    -----\n    This method provides a static User-Agent string commonly used for web browsers.\n    \"\"\"\n    return (\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67\"\n        \" Safari/537.36\"\n    )</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.demo_user_login","title":"demo_user_login","text":"<pre><code>demo_user_login() -&gt; GetTokenResponse</code></pre> <p>Retrieve authentication tokens for the demo user.</p> <p>Returns:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict containing authentication tokens including 'accessToken', 'accessTokenExpiresIn', and 'refreshToken'.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ParserError</code>             \u2013            <p>If there is an error parsing the request response.</p> </li> <li> <code>ServerError</code>             \u2013            <p>If there is a server error, connection timeout, or request exception.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def demo_user_login(self) -&gt; GetTokenResponse:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve authentication tokens for the demo user.\n\n    Returns\n    -------\n    GetTokenResponse\n        A TypedDict containing authentication tokens including 'accessToken',\n        'accessTokenExpiresIn', and 'refreshToken'.\n\n    Raises\n    ------\n    ParserError\n        If there is an error parsing the request response.\n    ServerError\n        If there is a server error, connection timeout, or request exception.\n    \"\"\"\n    url = f\"{API_BASE_URL}demo-user-token\"\n    try:\n        self._header[\"User-Agent\"] = self.get_user_agent()\n        with self.session.get(url, headers=self._header) as r:\n            _LOGGER.debug(\"Performed GET request %s [%s]:\\n%s\", url, r.status_code, r.text)\n\n            r.raise_for_status()\n            try:\n                data = r.json()\n                key = iter(GetTokenResponse.__annotations__)\n                token = {next(key): value for value in data.values()}\n                return cast(GetTokenResponse, token)\n            except requests.JSONDecodeError as exc:\n                raise ParserError(\"Demo user authentication failed due to an error parsing the request response\") from exc\n    except requests.HTTPError as exc:\n        raise ServerError(\n            \"Demo user authentication failed due to a server error \" f\"[{exc.response.status_code}: {exc.response.reason}]\"\n        ) from exc\n    except requests.Timeout as exc:\n        raise ServerError(\"Demo user authentication failed due a connection timeout\") from exc\n    except requests.RequestException as exc:\n        raise ServerError(\"Demo user authentication failed due to a request exception\") from exc</code></pre>"},{"location":"pyecotrend_ista/#pyecotrend_ista.PyEcotrendIsta.get_account","title":"get_account","text":"<pre><code>get_account() -&gt; AccountResponse | None</code></pre> <p>Retrieve the account information.</p> <p>Returns the <code>_account</code> attribute if it exists, otherwise returns None.</p> <p>Returns:</p> <ul> <li> <code>AccountResponse | None</code>           \u2013            <p>Account information if available, otherwise None.</p> </li> </ul> Source code in <code>src/pyecotrend_ista/pyecotrend_ista.py</code> <pre><code>def get_account(self) -&gt; AccountResponse | None:  # numpydoc ignore=ES01,EX01\n    \"\"\"\n    Retrieve the account information.\n\n    Returns the `_account` attribute if it exists, otherwise returns None.\n\n    Returns\n    -------\n    AccountResponse | None\n        Account information if available, otherwise None.\n    \"\"\"\n    return getattr(self, \"_account\", None)</code></pre>"},{"location":"types/","title":"Types","text":""},{"location":"types/#pyecotrend_ista.types","title":"pyecotrend_ista.types","text":"<p>Types for PyEcotrendIsta.</p> <p>This module defines various TypedDicts used in the PyEcotrendIsta client to represent responses and data structures from the ista EcoTrend API.</p> See Also <p>PyEcotrendIsta : The main client class for interacting with the ista EcoTrend API.</p> <p>Classes:</p> <ul> <li> <code>GetTokenResponse</code>           \u2013            <p>A TypedDict for the response returned by the getToken function.</p> </li> <li> <code>AccountResponse</code>           \u2013            <p>Represents the response for an account in the ista EcoTrend API.</p> </li> <li> <code>IstaMonthYear</code>           \u2013            <p>A TypedDict representing a month and year.</p> </li> <li> <code>IstaAverageConsumption</code>           \u2013            <p>A TypedDict representing average consumption values.</p> </li> <li> <code>IstaCompared</code>           \u2013            <p>A TypedDict representing compared values.</p> </li> <li> <code>IstaReading</code>           \u2013            <p>A TypedDict representing a reading.</p> </li> <li> <code>IstaTimeRange</code>           \u2013            <p>A TypedDict representing a time range.</p> </li> <li> <code>IstaBillingPeriod</code>           \u2013            <p>A TypedDict representing a billing period.</p> </li> <li> <code>IstaBillingPeriods</code>           \u2013            <p>A TypedDict representing the billing periods.</p> </li> <li> <code>IstaCostsByEnergyType</code>           \u2013            <p>A TypedDict representing the costs associated with a specific energy type.</p> </li> <li> <code>IstaPeriods</code>           \u2013            <p>A TypedDict representing data for a specific period.</p> </li> <li> <code>ConsumptionsResponse</code>           \u2013            <p>A TypedDict representing the response structure for consumption data.</p> </li> <li> <code>IstaConsumptionUnitAddress</code>           \u2013            <p>Represents the address of a consumption unit.</p> </li> <li> <code>IstaConsumptionUnitBookedServices</code>           \u2013            <p>Represents the booked extra services for an Ista consumption unit.</p> </li> <li> <code>IstaConsumptionUnit</code>           \u2013            <p>Represents a consumption unit.</p> </li> <li> <code>ConsumptionUnitDetailsResponse</code>           \u2013            <p>Represents the response details for consumption units.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.GetTokenResponse","title":"GetTokenResponse","text":"<p>A TypedDict for the response returned by the getToken function.</p> <p>Attributes:</p> <ul> <li> <code>access_token</code>               (<code>str</code>)           \u2013            <p>The access token issued by the authentication provider.</p> </li> <li> <code>expires_in</code>               (<code>int</code>)           \u2013            <p>The number of seconds until the access token expires.</p> </li> <li> <code>refresh_token</code>               (<code>str</code>)           \u2013            <p>The refresh token that can be used to obtain new access tokens.</p> </li> <li> <code>refresh_expires_in</code>               (<code>int</code>)           \u2013            <p>The number of seconds until the refresh token expires.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.AccountResponse","title":"AccountResponse","text":"<p>Represents the response for an account in the ista EcoTrend API.</p> <p>Attributes:</p> <ul> <li> <code>firstName</code>               (<code>str</code>)           \u2013            <p>The first name of the account holder.</p> </li> <li> <code>lastName</code>               (<code>str</code>)           \u2013            <p>The last name of the account holder.</p> </li> <li> <code>email</code>               (<code>str</code>)           \u2013            <p>The email address of the account holder.</p> </li> <li> <code>keycloakId</code>               (<code>str</code>)           \u2013            <p>The Keycloak ID associated with the account.</p> </li> <li> <code>country</code>               (<code>str</code>)           \u2013            <p>The country associated with the account.</p> </li> <li> <code>locale</code>               (<code>str</code>)           \u2013            <p>The locale setting for the account.</p> </li> <li> <code>authcode</code>               (<code>str</code>)           \u2013            <p>The authentication code for the account.</p> </li> <li> <code>tos</code>               (<code>str</code>)           \u2013            <p>The terms of service agreed to by the account holder.</p> </li> <li> <code>tosUpdated</code>               (<code>str</code>)           \u2013            <p>The date the terms of service were last updated.</p> </li> <li> <code>privacy</code>               (<code>str</code>)           \u2013            <p>The privacy setting for the account.</p> </li> <li> <code>mobileNumber</code>               (<code>str</code>)           \u2013            <p>The mobile phone number associated with the account.</p> </li> <li> <code>transitionMobileNumber</code>               (<code>str</code>)           \u2013            <p>The mobile number used during the transition period.</p> </li> <li> <code>unconfirmedPhoneNumber</code>               (<code>str</code>)           \u2013            <p>The unconfirmed phone number associated with the account.</p> </li> <li> <code>password</code>               (<code>str</code>)           \u2013            <p>The password for the account.</p> </li> <li> <code>enabled</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account is enabled.</p> </li> <li> <code>consumptionUnitUuids</code>               (<code>list of str</code>)           \u2013            <p>List of UUIDs for the consumption units.</p> </li> <li> <code>residentTimeRangeUuids</code>               (<code>list of str</code>)           \u2013            <p>List of UUIDs for the resident time ranges.</p> </li> <li> <code>ads</code>               (<code>bool</code>)           \u2013            <p>Indicates whether advertisements are enabled.</p> </li> <li> <code>marketing</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account holder has opted into marketing communications.</p> </li> <li> <code>fcmToken</code>               (<code>str</code>)           \u2013            <p>The FCM (Firebase Cloud Messaging) token for push notifications.</p> </li> <li> <code>betaPhase</code>               (<code>str</code>)           \u2013            <p>Indicates if the account is in the beta phase.</p> </li> <li> <code>notificationMethod</code>               (<code>str</code>)           \u2013            <p>The method of notification preferred by the account holder.</p> </li> <li> <code>emailConfirmed</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the email address is confirmed.</p> </li> <li> <code>isDemo</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the account is a demo account.</p> </li> <li> <code>userGroup</code>               (<code>str</code>)           \u2013            <p>The user group the account belongs to.</p> </li> <li> <code>mobileLoginStatus</code>               (<code>str</code>)           \u2013            <p>The status of mobile login for the account.</p> </li> <li> <code>residentAndConsumptionUuidsMap</code>               (<code>dict of str to str</code>)           \u2013            <p>A map of resident UUIDs to consumption unit UUIDs.</p> </li> <li> <code>activeConsumptionUnit</code>               (<code>str</code>)           \u2013            <p>The UUID of the active consumption unit.</p> </li> <li> <code>supportCode</code>               (<code>str</code>)           \u2013            <p>The support code for the account.</p> </li> <li> <code>notificationMethodEmailConfirmed</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the email for notification method is confirmed.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaMonthYear","title":"IstaMonthYear","text":"<p>A TypedDict representing a month and year.</p> <p>Attributes:</p> <ul> <li> <code>month</code>               (<code>int</code>)           \u2013            <p>The month value.</p> </li> <li> <code>year</code>               (<code>int</code>)           \u2013            <p>The year value.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaAverageConsumption","title":"IstaAverageConsumption","text":"<p>A TypedDict representing average consumption values.</p> <p>Attributes:</p> <ul> <li> <code>additionalAverageConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of additional average consumption.</p> </li> <li> <code>additionalAverageConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of additional average consumption.</p> </li> <li> <code>additionalResidentConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of additional resident consumption.</p> </li> <li> <code>additionalResidentConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of additional resident consumption.</p> </li> <li> <code>averageConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of average consumption.</p> </li> <li> <code>averageConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of average consumption.</p> </li> <li> <code>residentConsumptionPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage of resident consumption.</p> </li> <li> <code>residentConsumptionValue</code>               (<code>str</code>)           \u2013            <p>Value of resident consumption.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaCompared","title":"IstaCompared","text":"<p>A TypedDict representing compared values.</p> <p>Attributes:</p> <ul> <li> <code>comparedPercentage</code>               (<code>int</code>)           \u2013            <p>Percentage comparison value.</p> </li> <li> <code>comparedValue</code>               (<code>str</code>)           \u2013            <p>Compared value.</p> </li> <li> <code>lastYearValue</code>               (<code>float</code>)           \u2013            <p>Value from the last year.</p> </li> <li> <code>period</code>               (<code>IstaMonthYear</code>)           \u2013            <p>Period associated with the comparison.</p> </li> <li> <code>smiley</code>               (<code>str</code>)           \u2013            <p>Smiley associated with the comparison.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaReading","title":"IstaReading","text":"<p>A TypedDict representing a reading.</p> <p>Attributes:</p> <ul> <li> <code>additionalUnit</code>               (<code>str</code>)           \u2013            <p>Additional unit associated with the reading.</p> </li> <li> <code>additionalValue</code>               (<code>str</code>)           \u2013            <p>Additional value associated with the reading.</p> </li> <li> <code>averageConsumption</code>               (<code>IstaAverageConsumption</code>)           \u2013            <p>Average consumption details.</p> </li> <li> <code>comparedConsumption</code>               (<code>dict</code>)           \u2013            <p>Compared consumption details.</p> </li> <li> <code>comparedCost</code>               (<code>IstaCompared</code>)           \u2013            <p>Compared cost details.</p> </li> <li> <code>estimated</code>               (<code>bool</code>)           \u2013            <p>Indicates if the reading is estimated.</p> </li> <li> <code>type</code>               (<code>Literal['heating', 'warmwater', 'water']</code>)           \u2013            <p>Type of the reading (heating, warmwater, water).</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>Unit of measurement for the reading.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>Value of the reading.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaTimeRange","title":"IstaTimeRange","text":"<p>A TypedDict representing a time range.</p> <p>Attributes:</p> <ul> <li> <code>end</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The end of the time range.</p> </li> <li> <code>start</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The start of the time range.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaBillingPeriod","title":"IstaBillingPeriod","text":"<p>A TypedDict representing a billing period.</p> <p>Attributes:</p> <ul> <li> <code>exception</code>               (<code>(Any, optional)</code>)           \u2013            <p>Any exceptions related to this billing period. (data type unknown)</p> </li> <li> <code>readings</code>               (<code>list[IstaReading]</code>)           \u2013            <p>List of readings associated with this billing period.</p> </li> <li> <code>timeRange</code>               (<code>IstaTimeRange</code>)           \u2013            <p>The time range for this billing period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaBillingPeriods","title":"IstaBillingPeriods","text":"<p>A TypedDict representing the billing periods.</p> <p>Attributes:</p> <ul> <li> <code>currentBillingPeriod</code>               (<code>IstaBillingPeriod</code>)           \u2013            <p>The details of the current billing period.</p> </li> <li> <code>previousBillingPeriod</code>               (<code>IstaBillingPeriod</code>)           \u2013            <p>The details of the previous billing period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaCostsByEnergyType","title":"IstaCostsByEnergyType","text":"<p>A TypedDict representing the costs associated with a specific energy type.</p> <p>Attributes:</p> <ul> <li> <code>comparedCost</code>               (<code>IstaCompared</code>)           \u2013            <p>The cost comparison data for the energy type.</p> </li> <li> <code>estimated</code>               (<code>bool</code>)           \u2013            <p>Indicates whether the cost is estimated.</p> </li> <li> <code>type</code>               (<code>Literal['heating', 'warmwater', 'water']</code>)           \u2013            <p>The type of energy (heating, warm water, or water).</p> </li> <li> <code>unit</code>               (<code>str</code>)           \u2013            <p>The unit of measurement for the cost.</p> </li> <li> <code>value</code>               (<code>int</code>)           \u2013            <p>The cost value.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaPeriods","title":"IstaPeriods","text":"<p>A TypedDict representing data for a specific period.</p> <p>Attributes:</p> <ul> <li> <code>date</code>               (<code>IstaMonthYear</code>)           \u2013            <p>The month and year for the period.</p> </li> <li> <code>documentNumber</code>               (<code>str | None</code>)           \u2013            <p>The document number associated with the period, if any.</p> </li> <li> <code>exception</code>               (<code>Any</code>)           \u2013            <p>An exception associated with the period (data type unspecified).</p> </li> <li> <code>isSCEedBasic</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the period.</p> </li> <li> <code>readings</code>               (<code>list[IstaReading]</code>)           \u2013            <p>A list of readings recorded during the period.</p> </li> <li> <code>costsByEnergyType</code>               (<code>list[IstaCostsByEnergyType]</code>)           \u2013            <p>A list of costs categorized by energy type for the period.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.ConsumptionsResponse","title":"ConsumptionsResponse","text":"<p>A TypedDict representing the response structure for consumption data.</p> <p>Attributes:</p> <ul> <li> <code>co2Emissions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different periods.</p> </li> <li> <code>co2EmissionsBillingPeriods</code>               (<code>list[IstaBillingPeriods]</code>)           \u2013            <p>A list of CO2 emission data over different billing periods.</p> </li> <li> <code>consumptionUnitId</code>               (<code>str</code>)           \u2013            <p>The unique identifier for the consumption unit.</p> </li> <li> <code>consumptions</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of consumption data over different periods.</p> </li> <li> <code>consumptionsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The consumption data over different billing periods.</p> </li> <li> <code>costs</code>               (<code>list[IstaPeriods]</code>)           \u2013            <p>A list of cost data over different periods.</p> </li> <li> <code>costsBillingPeriods</code>               (<code>IstaBillingPeriods</code>)           \u2013            <p>The cost data over different billing periods.</p> </li> <li> <code>isSCEedBasicForCurrentMonth</code>               (<code>bool</code>)           \u2013            <p>Indicates if the SCEed basic plan is active for the current month.</p> </li> <li> <code>nonEEDBasicStartDate</code>               (<code>Any</code>)           \u2013            <p>The start date for non-EED basic plan (data type unknown).</p> </li> <li> <code>resident</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary containing resident information.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnitAddress","title":"IstaConsumptionUnitAddress","text":"<p>Represents the address of a consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>street</code>               (<code>str</code>)           \u2013            <p>The street name of the address.</p> </li> <li> <code>houseNumber</code>               (<code>str</code>)           \u2013            <p>The house number of the address.</p> </li> <li> <code>postalCode</code>               (<code>str</code>)           \u2013            <p>The postal code of the address.</p> </li> <li> <code>city</code>               (<code>str</code>)           \u2013            <p>The city of the address.</p> </li> <li> <code>country</code>               (<code>str</code>)           \u2013            <p>The country code of the address.</p> </li> <li> <code>floor</code>               (<code>str</code>)           \u2013            <p>The floor number of the address.</p> </li> <li> <code>propertyNumber</code>               (<code>str</code>)           \u2013            <p>The property number of the address.</p> </li> <li> <code>consumptionUnitNumber</code>               (<code>str</code>)           \u2013            <p>The consumption unit number associated with the address.</p> </li> <li> <code>idAtCustomerUser</code>               (<code>str</code>)           \u2013            <p>The ID assigned to the address at the customer user's end.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnitBookedServices","title":"IstaConsumptionUnitBookedServices","text":"<p>Represents the booked extra services for an Ista consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>cost</code>               (<code>bool</code>)           \u2013            <p>Indicates if cost service is booked.</p> </li> <li> <code>co2</code>               (<code>bool</code>)           \u2013            <p>Indicates if CO2 service is booked.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.IstaConsumptionUnit","title":"IstaConsumptionUnit","text":"<p>Represents a consumption unit.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The UUID of the consumption unit.</p> </li> <li> <code>address</code>               (<code>IstaConsumptionUnitAddress</code>)           \u2013            <p>The address details of the consumption unit.</p> </li> <li> <code>booked</code>               (<code>IstaConsumptionUnitBookedServices</code>)           \u2013            <p>The booked services for the consumption unit.</p> </li> <li> <code>propertyNumber</code>               (<code>str</code>)           \u2013            <p>The property number associated with the consumption unit.</p> </li> </ul>"},{"location":"types/#pyecotrend_ista.types.ConsumptionUnitDetailsResponse","title":"ConsumptionUnitDetailsResponse","text":"<p>Represents the response details for consumption units.</p> <p>Attributes:</p> <ul> <li> <code>consumptionUnits</code>               (<code>list[IstaConsumptionUnit]</code>)           \u2013            <p>The list of consumption units.</p> </li> <li> <code>coBranding</code>               (<code>Any</code>)           \u2013            <p>Co-branding information (data type unknown).</p> </li> </ul>"}]}